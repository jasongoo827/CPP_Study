# ğŸŒ² ê³ ê¸‰ ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬

> **ë‚œì´ë„**: Platinum  
> **ëŒ€í‘œ ë¬¸ì œ**: 2243(ì‚¬íƒ•ìƒì), 1615(êµì°¨ê°œìˆ˜ì„¸ê¸°), 12899(ë°ì´í„° êµ¬ì¡°)

---

## ğŸ¯ **í•µì‹¬ ê°œë…**

ê³ ê¸‰ ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ëŠ” **ë³µì¡í•œ ì¿¼ë¦¬ì™€ ì—…ë°ì´íŠ¸**ë¥¼ ì²˜ë¦¬í•˜ëŠ” ê³ ê¸‰ ê¸°ë²•ë“¤ì…ë‹ˆë‹¤:
- **Order Statistics Tree**: kë²ˆì§¸ ì›ì†Œ ì°¾ê¸°
- **Persistent Segment Tree**: ì´ì „ ë²„ì „ ì¿¼ë¦¬ ê°€ëŠ¥
- **2D Segment Tree**: 2ì°¨ì› êµ¬ê°„ ì¿¼ë¦¬
- **Dynamic Segment Tree**: ë™ì  ë…¸ë“œ ìƒì„±

---

## ğŸ”§ **ê¸°ë³¸ í…œí”Œë¦¿**

### **Order Statistics Tree (kë²ˆì§¸ ì›ì†Œ)**
```cpp
class OrderStatisticsTree {
private:
    vector<int> tree;
    int n, offset;
    
public:
    OrderStatisticsTree(int maxVal) {
        offset = maxVal;
        n = 2 * maxVal + 1;
        tree.resize(4 * n, 0);
    }
    
    void update(int val, int delta) {
        update(1, 0, n - 1, val + offset, delta);
    }
    
    // kë²ˆì§¸ë¡œ ì‘ì€ ì›ì†Œ (1-indexed)
    int kthElement(int k) {
        return kthElement(1, 0, n - 1, k) - offset;
    }
    
    // valë³´ë‹¤ ì‘ì€ ì›ì†Œì˜ ê°œìˆ˜
    int countLess(int val) {
        if (val + offset <= 0) return 0;
        return query(1, 0, n - 1, 0, val + offset - 1);
    }
    
private:
    void update(int node, int start, int end, int idx, int delta) {
        if (start == end) {
            tree[node] += delta;
        } else {
            int mid = (start + end) / 2;
            if (idx <= mid) {
                update(2 * node, start, mid, idx, delta);
            } else {
                update(2 * node + 1, mid + 1, end, idx, delta);
            }
            tree[node] = tree[2 * node] + tree[2 * node + 1];
        }
    }
    
    int kthElement(int node, int start, int end, int k) {
        if (start == end) {
            return start;
        }
        
        int mid = (start + end) / 2;
        int leftCount = tree[2 * node];
        
        if (k <= leftCount) {
            return kthElement(2 * node, start, mid, k);
        } else {
            return kthElement(2 * node + 1, mid + 1, end, k - leftCount);
        }
    }
    
    int query(int node, int start, int end, int l, int r) {
        if (r < start || end < l) return 0;
        if (l <= start && end <= r) return tree[node];
        
        int mid = (start + end) / 2;
        return query(2 * node, start, mid, l, r) + 
               query(2 * node + 1, mid + 1, end, l, r);
    }
};
```

### **Persistent Segment Tree**
```cpp
struct PersistentNode {
    int value;
    PersistentNode* left;
    PersistentNode* right;
    
    PersistentNode(int val = 0) : value(val), left(nullptr), right(nullptr) {}
    PersistentNode(PersistentNode* l, PersistentNode* r) : left(l), right(r) {
        value = (l ? l->value : 0) + (r ? r->value : 0);
    }
};

class PersistentSegmentTree {
private:
    vector<PersistentNode*> roots;
    int n;
    
public:
    PersistentSegmentTree(int size) : n(size) {
        roots.push_back(build(0, n - 1));
    }
    
    // ìƒˆë¡œìš´ ë²„ì „ ìƒì„±
    int newVersion(int version, int idx, int val) {
        roots.push_back(update(roots[version], 0, n - 1, idx, val));
        return roots.size() - 1;
    }
    
    // íŠ¹ì • ë²„ì „ì—ì„œ êµ¬ê°„ ì¿¼ë¦¬
    int query(int version, int l, int r) {
        return query(roots[version], 0, n - 1, l, r);
    }
    
private:
    PersistentNode* build(int start, int end) {
        if (start == end) {
            return new PersistentNode(0);
        }
        
        int mid = (start + end) / 2;
        PersistentNode* left = build(start, mid);
        PersistentNode* right = build(mid + 1, end);
        
        return new PersistentNode(left, right);
    }
    
    PersistentNode* update(PersistentNode* node, int start, int end, int idx, int val) {
        if (start == end) {
            return new PersistentNode(node->value + val);
        }
        
        int mid = (start + end) / 2;
        PersistentNode* newNode = new PersistentNode();
        
        if (idx <= mid) {
            newNode->left = update(node->left, start, mid, idx, val);
            newNode->right = node->right;
        } else {
            newNode->left = node->left;
            newNode->right = update(node->right, mid + 1, end, idx, val);
        }
        
        newNode->value = (newNode->left ? newNode->left->value : 0) + 
                        (newNode->right ? newNode->right->value : 0);
        
        return newNode;
    }
    
    int query(PersistentNode* node, int start, int end, int l, int r) {
        if (!node || r < start || end < l) return 0;
        if (l <= start && end <= r) return node->value;
        
        int mid = (start + end) / 2;
        return query(node->left, start, mid, l, r) + 
               query(node->right, mid + 1, end, l, r);
    }
};
```

### **2D Segment Tree**
```cpp
class SegmentTree2D {
private:
    vector<vector<int>> tree;
    int n, m;
    
public:
    SegmentTree2D(vector<vector<int>>& matrix) {
        n = matrix.size();
        m = matrix[0].size();
        tree.resize(4 * n, vector<int>(4 * m, 0));
        build(matrix);
    }
    
    void update(int x, int y, int val) {
        updateX(1, 0, n - 1, x, y, val);
    }
    
    int query(int x1, int y1, int x2, int y2) {
        return queryX(1, 0, n - 1, x1, y1, x2, y2);
    }
    
private:
    void buildY(int vx, int lx, int rx, int vy, int ly, int ry, vector<vector<int>>& matrix) {
        if (ly == ry) {
            if (lx == rx) {
                tree[vx][vy] = matrix[lx][ly];
            } else {
                tree[vx][vy] = tree[2 * vx][vy] + tree[2 * vx + 1][vy];
            }
        } else {
            int my = (ly + ry) / 2;
            buildY(vx, lx, rx, 2 * vy, ly, my, matrix);
            buildY(vx, lx, rx, 2 * vy + 1, my + 1, ry, matrix);
            tree[vx][vy] = tree[vx][2 * vy] + tree[vx][2 * vy + 1];
        }
    }
    
    void buildX(int vx, int lx, int rx, vector<vector<int>>& matrix) {
        if (lx != rx) {
            int mx = (lx + rx) / 2;
            buildX(2 * vx, lx, mx, matrix);
            buildX(2 * vx + 1, mx + 1, rx, matrix);
        }
        buildY(vx, lx, rx, 1, 0, m - 1, matrix);
    }
    
    void build(vector<vector<int>>& matrix) {
        buildX(1, 0, n - 1, matrix);
    }
    
    void updateY(int vx, int lx, int rx, int vy, int ly, int ry, int x, int y, int val) {
        if (ly == ry) {
            if (lx == rx) {
                tree[vx][vy] = val;
            } else {
                tree[vx][vy] = tree[2 * vx][vy] + tree[2 * vx + 1][vy];
            }
        } else {
            int my = (ly + ry) / 2;
            if (y <= my) {
                updateY(vx, lx, rx, 2 * vy, ly, my, x, y, val);
            } else {
                updateY(vx, lx, rx, 2 * vy + 1, my + 1, ry, x, y, val);
            }
            tree[vx][vy] = tree[vx][2 * vy] + tree[vx][2 * vy + 1];
        }
    }
    
    void updateX(int vx, int lx, int rx, int x, int y, int val) {
        if (lx != rx) {
            int mx = (lx + rx) / 2;
            if (x <= mx) {
                updateX(2 * vx, lx, mx, x, y, val);
            } else {
                updateX(2 * vx + 1, mx + 1, rx, x, y, val);
            }
        }
        updateY(vx, lx, rx, 1, 0, m - 1, x, y, val);
    }
    
    int queryY(int vx, int vy, int ly, int ry, int y1, int y2) {
        if (y1 > ry || y2 < ly) return 0;
        if (y1 <= ly && ry <= y2) return tree[vx][vy];
        
        int my = (ly + ry) / 2;
        return queryY(vx, 2 * vy, ly, my, y1, y2) + 
               queryY(vx, 2 * vy + 1, my + 1, ry, y1, y2);
    }
    
    int queryX(int vx, int lx, int rx, int x1, int y1, int x2, int y2) {
        if (x1 > rx || x2 < lx) return 0;
        if (x1 <= lx && rx <= x2) return queryY(vx, 1, 0, m - 1, y1, y2);
        
        int mx = (lx + rx) / 2;
        return queryX(2 * vx, lx, mx, x1, y1, x2, y2) + 
               queryX(2 * vx + 1, mx + 1, rx, x1, y1, x2, y2);
    }
};
```

### **Dynamic Segment Tree**
```cpp
struct DynamicNode {
    int value;
    DynamicNode* left;
    DynamicNode* right;
    
    DynamicNode() : value(0), left(nullptr), right(nullptr) {}
};

class DynamicSegmentTree {
private:
    DynamicNode* root;
    int n;
    
public:
    DynamicSegmentTree(int size) : n(size) {
        root = new DynamicNode();
    }
    
    void update(int idx, int val) {
        update(root, 0, n - 1, idx, val);
    }
    
    int query(int l, int r) {
        return query(root, 0, n - 1, l, r);
    }
    
private:
    void update(DynamicNode* node, int start, int end, int idx, int val) {
        if (start == end) {
            node->value += val;
            return;
        }
        
        int mid = (start + end) / 2;
        
        if (idx <= mid) {
            if (!node->left) node->left = new DynamicNode();
            update(node->left, start, mid, idx, val);
        } else {
            if (!node->right) node->right = new DynamicNode();
            update(node->right, mid + 1, end, idx, val);
        }
        
        node->value = (node->left ? node->left->value : 0) + 
                     (node->right ? node->right->value : 0);
    }
    
    int query(DynamicNode* node, int start, int end, int l, int r) {
        if (!node || r < start || end < l) return 0;
        if (l <= start && end <= r) return node->value;
        
        int mid = (start + end) / 2;
        return query(node->left, start, mid, l, r) + 
               query(node->right, mid + 1, end, l, r);
    }
};
```

---

## ğŸ’¡ **ê³ ê¸‰ íŒ¨í„´**

### **1. Merge Sort Tree**
```cpp
class MergeSortTree {
private:
    vector<vector<int>> tree;
    int n;
    
public:
    MergeSortTree(vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n);
        build(arr, 1, 0, n - 1);
    }
    
    // êµ¬ê°„ [l, r]ì—ì„œ valë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì€ ì›ì†Œì˜ ê°œìˆ˜
    int query(int l, int r, int val) {
        return query(1, 0, n - 1, l, r, val);
    }
    
private:
    void build(vector<int>& arr, int node, int start, int end) {
        if (start == end) {
            tree[node].push_back(arr[start]);
        } else {
            int mid = (start + end) / 2;
            build(arr, 2 * node, start, mid);
            build(arr, 2 * node + 1, mid + 1, end);
            
            // ë‘ ìì‹ì˜ ì •ë ¬ëœ ë°°ì—´ì„ ë³‘í•©
            merge(tree[2 * node].begin(), tree[2 * node].end(),
                  tree[2 * node + 1].begin(), tree[2 * node + 1].end(),
                  back_inserter(tree[node]));
        }
    }
    
    int query(int node, int start, int end, int l, int r, int val) {
        if (r < start || end < l) return 0;
        if (l <= start && end <= r) {
            return upper_bound(tree[node].begin(), tree[node].end(), val) - tree[node].begin();
        }
        
        int mid = (start + end) / 2;
        return query(2 * node, start, mid, l, r, val) + 
               query(2 * node + 1, mid + 1, end, l, r, val);
    }
};
```

### **2. Wavelet Tree**
```cpp
class WaveletTree {
private:
    struct Node {
        vector<int> prefix;
        Node* left;
        Node* right;
        
        Node() : left(nullptr), right(nullptr) {}
    };
    
    Node* root;
    int minVal, maxVal;
    
public:
    WaveletTree(vector<int>& arr) {
        if (arr.empty()) return;
        
        minVal = *min_element(arr.begin(), arr.end());
        maxVal = *max_element(arr.begin(), arr.end());
        root = build(arr, minVal, maxVal);
    }
    
    // kë²ˆì§¸ ì›ì†Œ (0-indexed)
    int kth(int l, int r, int k) {
        return kth(root, l, r, k, minVal, maxVal);
    }
    
    // valë³´ë‹¤ ì‘ì€ ì›ì†Œì˜ ê°œìˆ˜
    int rank(int l, int r, int val) {
        return rank(root, l, r, val, minVal, maxVal);
    }
    
private:
    Node* build(vector<int>& arr, int low, int high) {
        if (low == high) return new Node();
        
        Node* node = new Node();
        int mid = (low + high) / 2;
        
        node->prefix.reserve(arr.size() + 1);
        node->prefix.push_back(0);
        
        vector<int> leftArr, rightArr;
        
        for (int x : arr) {
            node->prefix.push_back(node->prefix.back() + (x <= mid));
            
            if (x <= mid) {
                leftArr.push_back(x);
            } else {
                rightArr.push_back(x);
            }
        }
        
        node->left = build(leftArr, low, mid);
        node->right = build(rightArr, mid + 1, high);
        
        return node;
    }
    
    int kth(Node* node, int l, int r, int k, int low, int high) {
        if (low == high) return low;
        
        int mid = (low + high) / 2;
        int leftCount = node->prefix[r + 1] - node->prefix[l];
        
        if (k < leftCount) {
            int newL = node->prefix[l];
            int newR = node->prefix[r + 1] - 1;
            return kth(node->left, newL, newR, k, low, mid);
        } else {
            int newL = l - node->prefix[l];
            int newR = r - node->prefix[r + 1];
            return kth(node->right, newL, newR, k - leftCount, mid + 1, high);
        }
    }
    
    int rank(Node* node, int l, int r, int val, int low, int high) {
        if (val < low) return 0;
        if (val >= high) return r - l + 1;
        
        int mid = (low + high) / 2;
        int leftCount = node->prefix[r + 1] - node->prefix[l];
        
        if (val <= mid) {
            int newL = node->prefix[l];
            int newR = node->prefix[r + 1] - 1;
            return rank(node->left, newL, newR, val, low, mid);
        } else {
            int newL = l - node->prefix[l];
            int newR = r - node->prefix[r + 1];
            return leftCount + rank(node->right, newL, newR, val, mid + 1, high);
        }
    }
};
```

---

## ğŸ” **ì‹¤ì œ ì˜ˆì‹œ**

### **ì˜ˆì‹œ 1: ì‚¬íƒ•ìƒì (2243ë²ˆ)**
```cpp
#include <iostream>
#include <vector>

class OrderStatisticsTree {
private:
    vector<long long> tree;
    int n;
    
public:
    OrderStatisticsTree() {
        n = 1000000;  // ì‚¬íƒ• ë§›ì˜ ë²”ìœ„
        tree.resize(4 * n, 0);
    }
    
    void update(int taste, long long count) {
        update(1, 1, n, taste, count);
    }
    
    int kthCandy(long long k) {
        return kthCandy(1, 1, n, k);
    }
    
private:
    void update(int node, int start, int end, int taste, long long count) {
        if (start == end) {
            tree[node] += count;
        } else {
            int mid = (start + end) / 2;
            if (taste <= mid) {
                update(2 * node, start, mid, taste, count);
            } else {
                update(2 * node + 1, mid + 1, end, taste, count);
            }
            tree[node] = tree[2 * node] + tree[2 * node + 1];
        }
    }
    
    int kthCandy(int node, int start, int end, long long k) {
        if (start == end) {
            return start;
        }
        
        int mid = (start + end) / 2;
        long long leftCount = tree[2 * node];
        
        if (k <= leftCount) {
            return kthCandy(2 * node, start, mid, k);
        } else {
            return kthCandy(2 * node + 1, mid + 1, end, k - leftCount);
        }
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    cin >> n;
    
    OrderStatisticsTree ost;
    
    for (int i = 0; i < n; i++) {
        int a;
        cin >> a;
        
        if (a == 1) {
            long long b;
            cin >> b;
            int candy = ost.kthCandy(b);
            cout << candy << "\n";
            ost.update(candy, -1);  // ì‚¬íƒ• í•˜ë‚˜ ì œê±°
        } else {
            int b;
            long long c;
            cin >> b >> c;
            ost.update(b, c);  // ì‚¬íƒ• ì¶”ê°€
        }
    }
    
    return 0;
}
```

---

## âš¡ **ìµœì í™” ê¸°ë²•**

### **1. ì¢Œí‘œ ì••ì¶•**
```cpp
// í° ì¢Œí‘œ ë²”ìœ„ë¥¼ ì‘ì€ ë²”ìœ„ë¡œ ì••ì¶•
vector<int> compress(vector<int>& coords) {
    vector<int> sorted = coords;
    sort(sorted.begin(), sorted.end());
    sorted.erase(unique(sorted.begin(), sorted.end()), sorted.end());
    
    for (int& coord : coords) {
        coord = lower_bound(sorted.begin(), sorted.end(), coord) - sorted.begin();
    }
    
    return sorted;  // ì›ë³¸ ê°’ë“¤
}
```

### **2. ë©”ëª¨ë¦¬ í’€**
```cpp
class NodePool {
private:
    vector<DynamicNode> pool;
    int index;
    
public:
    NodePool(int size) : pool(size), index(0) {}
    
    DynamicNode* allocate() {
        return &pool[index++];
    }
};
```

### **3. ë¹„íŠ¸ ìµœì í™”**
```cpp
// 64ë¹„íŠ¸ ì •ìˆ˜ë¡œ ì—¬ëŸ¬ ê°’ì„ íŒ¨í‚¹
struct PackedValue {
    long long data;
    
    int getSum() const { return data & 0xFFFFFFFF; }
    int getMax() const { return (data >> 32) & 0xFFFFFFFF; }
    
    void setSum(int sum) { data = (data & 0xFFFFFFFF00000000LL) | sum; }
    void setMax(int max) { data = (data & 0xFFFFFFFFLL) | ((long long)max << 32); }
};
```

---

## ğŸ“Š **ì‹œê°„/ê³µê°„ ë³µì¡ë„**

### **Order Statistics Tree**
- **ì—…ë°ì´íŠ¸**: O(log n)
- **kë²ˆì§¸ ì›ì†Œ**: O(log n)
- **ê³µê°„**: O(n)

### **Persistent Segment Tree**
- **ì—…ë°ì´íŠ¸**: O(log n) (ìƒˆ ë…¸ë“œë“¤ë§Œ ìƒì„±)
- **ì¿¼ë¦¬**: O(log n)
- **ê³µê°„**: O(m log n) (m: ë²„ì „ ìˆ˜)

### **2D Segment Tree**
- **ì—…ë°ì´íŠ¸**: O(log n Ã— log m)
- **ì¿¼ë¦¬**: O(log n Ã— log m)
- **ê³µê°„**: O(n Ã— m)

---

## ğŸ“ **ê´€ë ¨ ë¬¸ì œ**

### **Order Statistics**
- 2243: ì‚¬íƒ•ìƒì
- 12899: ë°ì´í„° êµ¬ì¡°
- 7469: Kë²ˆì§¸ ìˆ˜

### **Persistent**
- 13544: ìˆ˜ì—´ê³¼ ì¿¼ë¦¬ 3
- 11932: íŠ¸ë¦¬ì™€ Kë²ˆì§¸ ìˆ˜

### **2D Segment Tree**
- 11658: êµ¬ê°„ í•© êµ¬í•˜ê¸° 3
- 1849: ìˆœì—´

### **Dynamic**
- 1615: êµì°¨ê°œìˆ˜ì„¸ê¸°
- 2912: ë°±ì„¤ê³µì£¼ì™€ ë‚œìŸì´

---

**ğŸ”‘ í•µì‹¬ í¬ì¸íŠ¸**:
- **ì¢Œí‘œ ì••ì¶•**ìœ¼ë¡œ ë©”ëª¨ë¦¬ ì ˆì•½
- **ë™ì  í• ë‹¹**ìœ¼ë¡œ í•„ìš”í•œ ë…¸ë“œë§Œ ìƒì„±
- **ì§€ì†ì„±**ìœ¼ë¡œ ì´ì „ ìƒíƒœ ì¿¼ë¦¬ ê°€ëŠ¥
- **ë‹¤ì°¨ì›** í™•ì¥ìœ¼ë¡œ ë³µì¡í•œ ì¿¼ë¦¬ ì²˜ë¦¬