# 🌲 고급 세그먼트 트리

> **난이도**: Platinum  
> **대표 문제**: 2243(사탕상자), 1615(교차개수세기), 12899(데이터 구조)

---

## 🎯 **핵심 개념**

고급 세그먼트 트리는 **복잡한 쿼리와 업데이트**를 처리하는 고급 기법들입니다:
- **Order Statistics Tree**: k번째 원소 찾기
- **Persistent Segment Tree**: 이전 버전 쿼리 가능
- **2D Segment Tree**: 2차원 구간 쿼리
- **Dynamic Segment Tree**: 동적 노드 생성

---

## 🔧 **기본 템플릿**

### **Order Statistics Tree (k번째 원소)**
```cpp
class OrderStatisticsTree {
private:
    vector<int> tree;
    int n, offset;
    
public:
    OrderStatisticsTree(int maxVal) {
        offset = maxVal;
        n = 2 * maxVal + 1;
        tree.resize(4 * n, 0);
    }
    
    void update(int val, int delta) {
        update(1, 0, n - 1, val + offset, delta);
    }
    
    // k번째로 작은 원소 (1-indexed)
    int kthElement(int k) {
        return kthElement(1, 0, n - 1, k) - offset;
    }
    
    // val보다 작은 원소의 개수
    int countLess(int val) {
        if (val + offset <= 0) return 0;
        return query(1, 0, n - 1, 0, val + offset - 1);
    }
    
private:
    void update(int node, int start, int end, int idx, int delta) {
        if (start == end) {
            tree[node] += delta;
        } else {
            int mid = (start + end) / 2;
            if (idx <= mid) {
                update(2 * node, start, mid, idx, delta);
            } else {
                update(2 * node + 1, mid + 1, end, idx, delta);
            }
            tree[node] = tree[2 * node] + tree[2 * node + 1];
        }
    }
    
    int kthElement(int node, int start, int end, int k) {
        if (start == end) {
            return start;
        }
        
        int mid = (start + end) / 2;
        int leftCount = tree[2 * node];
        
        if (k <= leftCount) {
            return kthElement(2 * node, start, mid, k);
        } else {
            return kthElement(2 * node + 1, mid + 1, end, k - leftCount);
        }
    }
    
    int query(int node, int start, int end, int l, int r) {
        if (r < start || end < l) return 0;
        if (l <= start && end <= r) return tree[node];
        
        int mid = (start + end) / 2;
        return query(2 * node, start, mid, l, r) + 
               query(2 * node + 1, mid + 1, end, l, r);
    }
};
```

### **Persistent Segment Tree**
```cpp
struct PersistentNode {
    int value;
    PersistentNode* left;
    PersistentNode* right;
    
    PersistentNode(int val = 0) : value(val), left(nullptr), right(nullptr) {}
    PersistentNode(PersistentNode* l, PersistentNode* r) : left(l), right(r) {
        value = (l ? l->value : 0) + (r ? r->value : 0);
    }
};

class PersistentSegmentTree {
private:
    vector<PersistentNode*> roots;
    int n;
    
public:
    PersistentSegmentTree(int size) : n(size) {
        roots.push_back(build(0, n - 1));
    }
    
    // 새로운 버전 생성
    int newVersion(int version, int idx, int val) {
        roots.push_back(update(roots[version], 0, n - 1, idx, val));
        return roots.size() - 1;
    }
    
    // 특정 버전에서 구간 쿼리
    int query(int version, int l, int r) {
        return query(roots[version], 0, n - 1, l, r);
    }
    
private:
    PersistentNode* build(int start, int end) {
        if (start == end) {
            return new PersistentNode(0);
        }
        
        int mid = (start + end) / 2;
        PersistentNode* left = build(start, mid);
        PersistentNode* right = build(mid + 1, end);
        
        return new PersistentNode(left, right);
    }
    
    PersistentNode* update(PersistentNode* node, int start, int end, int idx, int val) {
        if (start == end) {
            return new PersistentNode(node->value + val);
        }
        
        int mid = (start + end) / 2;
        PersistentNode* newNode = new PersistentNode();
        
        if (idx <= mid) {
            newNode->left = update(node->left, start, mid, idx, val);
            newNode->right = node->right;
        } else {
            newNode->left = node->left;
            newNode->right = update(node->right, mid + 1, end, idx, val);
        }
        
        newNode->value = (newNode->left ? newNode->left->value : 0) + 
                        (newNode->right ? newNode->right->value : 0);
        
        return newNode;
    }
    
    int query(PersistentNode* node, int start, int end, int l, int r) {
        if (!node || r < start || end < l) return 0;
        if (l <= start && end <= r) return node->value;
        
        int mid = (start + end) / 2;
        return query(node->left, start, mid, l, r) + 
               query(node->right, mid + 1, end, l, r);
    }
};
```

### **2D Segment Tree**
```cpp
class SegmentTree2D {
private:
    vector<vector<int>> tree;
    int n, m;
    
public:
    SegmentTree2D(vector<vector<int>>& matrix) {
        n = matrix.size();
        m = matrix[0].size();
        tree.resize(4 * n, vector<int>(4 * m, 0));
        build(matrix);
    }
    
    void update(int x, int y, int val) {
        updateX(1, 0, n - 1, x, y, val);
    }
    
    int query(int x1, int y1, int x2, int y2) {
        return queryX(1, 0, n - 1, x1, y1, x2, y2);
    }
    
private:
    void buildY(int vx, int lx, int rx, int vy, int ly, int ry, vector<vector<int>>& matrix) {
        if (ly == ry) {
            if (lx == rx) {
                tree[vx][vy] = matrix[lx][ly];
            } else {
                tree[vx][vy] = tree[2 * vx][vy] + tree[2 * vx + 1][vy];
            }
        } else {
            int my = (ly + ry) / 2;
            buildY(vx, lx, rx, 2 * vy, ly, my, matrix);
            buildY(vx, lx, rx, 2 * vy + 1, my + 1, ry, matrix);
            tree[vx][vy] = tree[vx][2 * vy] + tree[vx][2 * vy + 1];
        }
    }
    
    void buildX(int vx, int lx, int rx, vector<vector<int>>& matrix) {
        if (lx != rx) {
            int mx = (lx + rx) / 2;
            buildX(2 * vx, lx, mx, matrix);
            buildX(2 * vx + 1, mx + 1, rx, matrix);
        }
        buildY(vx, lx, rx, 1, 0, m - 1, matrix);
    }
    
    void build(vector<vector<int>>& matrix) {
        buildX(1, 0, n - 1, matrix);
    }
    
    void updateY(int vx, int lx, int rx, int vy, int ly, int ry, int x, int y, int val) {
        if (ly == ry) {
            if (lx == rx) {
                tree[vx][vy] = val;
            } else {
                tree[vx][vy] = tree[2 * vx][vy] + tree[2 * vx + 1][vy];
            }
        } else {
            int my = (ly + ry) / 2;
            if (y <= my) {
                updateY(vx, lx, rx, 2 * vy, ly, my, x, y, val);
            } else {
                updateY(vx, lx, rx, 2 * vy + 1, my + 1, ry, x, y, val);
            }
            tree[vx][vy] = tree[vx][2 * vy] + tree[vx][2 * vy + 1];
        }
    }
    
    void updateX(int vx, int lx, int rx, int x, int y, int val) {
        if (lx != rx) {
            int mx = (lx + rx) / 2;
            if (x <= mx) {
                updateX(2 * vx, lx, mx, x, y, val);
            } else {
                updateX(2 * vx + 1, mx + 1, rx, x, y, val);
            }
        }
        updateY(vx, lx, rx, 1, 0, m - 1, x, y, val);
    }
    
    int queryY(int vx, int vy, int ly, int ry, int y1, int y2) {
        if (y1 > ry || y2 < ly) return 0;
        if (y1 <= ly && ry <= y2) return tree[vx][vy];
        
        int my = (ly + ry) / 2;
        return queryY(vx, 2 * vy, ly, my, y1, y2) + 
               queryY(vx, 2 * vy + 1, my + 1, ry, y1, y2);
    }
    
    int queryX(int vx, int lx, int rx, int x1, int y1, int x2, int y2) {
        if (x1 > rx || x2 < lx) return 0;
        if (x1 <= lx && rx <= x2) return queryY(vx, 1, 0, m - 1, y1, y2);
        
        int mx = (lx + rx) / 2;
        return queryX(2 * vx, lx, mx, x1, y1, x2, y2) + 
               queryX(2 * vx + 1, mx + 1, rx, x1, y1, x2, y2);
    }
};
```

### **Dynamic Segment Tree**
```cpp
struct DynamicNode {
    int value;
    DynamicNode* left;
    DynamicNode* right;
    
    DynamicNode() : value(0), left(nullptr), right(nullptr) {}
};

class DynamicSegmentTree {
private:
    DynamicNode* root;
    int n;
    
public:
    DynamicSegmentTree(int size) : n(size) {
        root = new DynamicNode();
    }
    
    void update(int idx, int val) {
        update(root, 0, n - 1, idx, val);
    }
    
    int query(int l, int r) {
        return query(root, 0, n - 1, l, r);
    }
    
private:
    void update(DynamicNode* node, int start, int end, int idx, int val) {
        if (start == end) {
            node->value += val;
            return;
        }
        
        int mid = (start + end) / 2;
        
        if (idx <= mid) {
            if (!node->left) node->left = new DynamicNode();
            update(node->left, start, mid, idx, val);
        } else {
            if (!node->right) node->right = new DynamicNode();
            update(node->right, mid + 1, end, idx, val);
        }
        
        node->value = (node->left ? node->left->value : 0) + 
                     (node->right ? node->right->value : 0);
    }
    
    int query(DynamicNode* node, int start, int end, int l, int r) {
        if (!node || r < start || end < l) return 0;
        if (l <= start && end <= r) return node->value;
        
        int mid = (start + end) / 2;
        return query(node->left, start, mid, l, r) + 
               query(node->right, mid + 1, end, l, r);
    }
};
```

---

## 💡 **고급 패턴**

### **1. Merge Sort Tree**
```cpp
class MergeSortTree {
private:
    vector<vector<int>> tree;
    int n;
    
public:
    MergeSortTree(vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n);
        build(arr, 1, 0, n - 1);
    }
    
    // 구간 [l, r]에서 val보다 작거나 같은 원소의 개수
    int query(int l, int r, int val) {
        return query(1, 0, n - 1, l, r, val);
    }
    
private:
    void build(vector<int>& arr, int node, int start, int end) {
        if (start == end) {
            tree[node].push_back(arr[start]);
        } else {
            int mid = (start + end) / 2;
            build(arr, 2 * node, start, mid);
            build(arr, 2 * node + 1, mid + 1, end);
            
            // 두 자식의 정렬된 배열을 병합
            merge(tree[2 * node].begin(), tree[2 * node].end(),
                  tree[2 * node + 1].begin(), tree[2 * node + 1].end(),
                  back_inserter(tree[node]));
        }
    }
    
    int query(int node, int start, int end, int l, int r, int val) {
        if (r < start || end < l) return 0;
        if (l <= start && end <= r) {
            return upper_bound(tree[node].begin(), tree[node].end(), val) - tree[node].begin();
        }
        
        int mid = (start + end) / 2;
        return query(2 * node, start, mid, l, r, val) + 
               query(2 * node + 1, mid + 1, end, l, r, val);
    }
};
```

### **2. Wavelet Tree**
```cpp
class WaveletTree {
private:
    struct Node {
        vector<int> prefix;
        Node* left;
        Node* right;
        
        Node() : left(nullptr), right(nullptr) {}
    };
    
    Node* root;
    int minVal, maxVal;
    
public:
    WaveletTree(vector<int>& arr) {
        if (arr.empty()) return;
        
        minVal = *min_element(arr.begin(), arr.end());
        maxVal = *max_element(arr.begin(), arr.end());
        root = build(arr, minVal, maxVal);
    }
    
    // k번째 원소 (0-indexed)
    int kth(int l, int r, int k) {
        return kth(root, l, r, k, minVal, maxVal);
    }
    
    // val보다 작은 원소의 개수
    int rank(int l, int r, int val) {
        return rank(root, l, r, val, minVal, maxVal);
    }
    
private:
    Node* build(vector<int>& arr, int low, int high) {
        if (low == high) return new Node();
        
        Node* node = new Node();
        int mid = (low + high) / 2;
        
        node->prefix.reserve(arr.size() + 1);
        node->prefix.push_back(0);
        
        vector<int> leftArr, rightArr;
        
        for (int x : arr) {
            node->prefix.push_back(node->prefix.back() + (x <= mid));
            
            if (x <= mid) {
                leftArr.push_back(x);
            } else {
                rightArr.push_back(x);
            }
        }
        
        node->left = build(leftArr, low, mid);
        node->right = build(rightArr, mid + 1, high);
        
        return node;
    }
    
    int kth(Node* node, int l, int r, int k, int low, int high) {
        if (low == high) return low;
        
        int mid = (low + high) / 2;
        int leftCount = node->prefix[r + 1] - node->prefix[l];
        
        if (k < leftCount) {
            int newL = node->prefix[l];
            int newR = node->prefix[r + 1] - 1;
            return kth(node->left, newL, newR, k, low, mid);
        } else {
            int newL = l - node->prefix[l];
            int newR = r - node->prefix[r + 1];
            return kth(node->right, newL, newR, k - leftCount, mid + 1, high);
        }
    }
    
    int rank(Node* node, int l, int r, int val, int low, int high) {
        if (val < low) return 0;
        if (val >= high) return r - l + 1;
        
        int mid = (low + high) / 2;
        int leftCount = node->prefix[r + 1] - node->prefix[l];
        
        if (val <= mid) {
            int newL = node->prefix[l];
            int newR = node->prefix[r + 1] - 1;
            return rank(node->left, newL, newR, val, low, mid);
        } else {
            int newL = l - node->prefix[l];
            int newR = r - node->prefix[r + 1];
            return leftCount + rank(node->right, newL, newR, val, mid + 1, high);
        }
    }
};
```

---

## 🔍 **실제 예시**

### **예시 1: 사탕상자 (2243번)**
```cpp
#include <iostream>
#include <vector>

class OrderStatisticsTree {
private:
    vector<long long> tree;
    int n;
    
public:
    OrderStatisticsTree() {
        n = 1000000;  // 사탕 맛의 범위
        tree.resize(4 * n, 0);
    }
    
    void update(int taste, long long count) {
        update(1, 1, n, taste, count);
    }
    
    int kthCandy(long long k) {
        return kthCandy(1, 1, n, k);
    }
    
private:
    void update(int node, int start, int end, int taste, long long count) {
        if (start == end) {
            tree[node] += count;
        } else {
            int mid = (start + end) / 2;
            if (taste <= mid) {
                update(2 * node, start, mid, taste, count);
            } else {
                update(2 * node + 1, mid + 1, end, taste, count);
            }
            tree[node] = tree[2 * node] + tree[2 * node + 1];
        }
    }
    
    int kthCandy(int node, int start, int end, long long k) {
        if (start == end) {
            return start;
        }
        
        int mid = (start + end) / 2;
        long long leftCount = tree[2 * node];
        
        if (k <= leftCount) {
            return kthCandy(2 * node, start, mid, k);
        } else {
            return kthCandy(2 * node + 1, mid + 1, end, k - leftCount);
        }
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    cin >> n;
    
    OrderStatisticsTree ost;
    
    for (int i = 0; i < n; i++) {
        int a;
        cin >> a;
        
        if (a == 1) {
            long long b;
            cin >> b;
            int candy = ost.kthCandy(b);
            cout << candy << "\n";
            ost.update(candy, -1);  // 사탕 하나 제거
        } else {
            int b;
            long long c;
            cin >> b >> c;
            ost.update(b, c);  // 사탕 추가
        }
    }
    
    return 0;
}
```

---

## ⚡ **최적화 기법**

### **1. 좌표 압축**
```cpp
// 큰 좌표 범위를 작은 범위로 압축
vector<int> compress(vector<int>& coords) {
    vector<int> sorted = coords;
    sort(sorted.begin(), sorted.end());
    sorted.erase(unique(sorted.begin(), sorted.end()), sorted.end());
    
    for (int& coord : coords) {
        coord = lower_bound(sorted.begin(), sorted.end(), coord) - sorted.begin();
    }
    
    return sorted;  // 원본 값들
}
```

### **2. 메모리 풀**
```cpp
class NodePool {
private:
    vector<DynamicNode> pool;
    int index;
    
public:
    NodePool(int size) : pool(size), index(0) {}
    
    DynamicNode* allocate() {
        return &pool[index++];
    }
};
```

### **3. 비트 최적화**
```cpp
// 64비트 정수로 여러 값을 패킹
struct PackedValue {
    long long data;
    
    int getSum() const { return data & 0xFFFFFFFF; }
    int getMax() const { return (data >> 32) & 0xFFFFFFFF; }
    
    void setSum(int sum) { data = (data & 0xFFFFFFFF00000000LL) | sum; }
    void setMax(int max) { data = (data & 0xFFFFFFFFLL) | ((long long)max << 32); }
};
```

---

## 📊 **시간/공간 복잡도**

### **Order Statistics Tree**
- **업데이트**: O(log n)
- **k번째 원소**: O(log n)
- **공간**: O(n)

### **Persistent Segment Tree**
- **업데이트**: O(log n) (새 노드들만 생성)
- **쿼리**: O(log n)
- **공간**: O(m log n) (m: 버전 수)

### **2D Segment Tree**
- **업데이트**: O(log n × log m)
- **쿼리**: O(log n × log m)
- **공간**: O(n × m)

---

## 📝 **관련 문제**

### **Order Statistics**
- 2243: 사탕상자
- 12899: 데이터 구조
- 7469: K번째 수

### **Persistent**
- 13544: 수열과 쿼리 3
- 11932: 트리와 K번째 수

### **2D Segment Tree**
- 11658: 구간 합 구하기 3
- 1849: 순열

### **Dynamic**
- 1615: 교차개수세기
- 2912: 백설공주와 난쟁이

---

**🔑 핵심 포인트**:
- **좌표 압축**으로 메모리 절약
- **동적 할당**으로 필요한 노드만 생성
- **지속성**으로 이전 상태 쿼리 가능
- **다차원** 확장으로 복잡한 쿼리 처리