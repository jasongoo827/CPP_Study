# ğŸ’ ê³ ê¸‰ ë™ì ê³„íšë²•

> **ë‚œì´ë„**: Gold ~ Platinum  
> **ëŒ€í‘œ ë¬¸ì œ**: 12865(í‰ë²”í•œ ë°°ë‚­), 2098(ì™¸íŒì› ìˆœíšŒ), 1562(ê³„ë‹¨ ìˆ˜)

---

## ğŸ¯ **í•µì‹¬ ê°œë…**

ê³ ê¸‰ DPëŠ” **ë³µì¡í•œ ìƒíƒœì™€ ì „ì´**ë¥¼ ë‹¤ë£¨ëŠ” ë™ì ê³„íšë²• ê¸°ë²•ë“¤ì…ë‹ˆë‹¤:
- **ë°°ë‚­ ë¬¸ì œ(Knapsack)**: ì œí•œëœ ìš©ëŸ‰ì—ì„œ ìµœì  ì„ íƒ
- **ë¹„íŠ¸ë§ˆìŠ¤í‚¹ DP**: ì§‘í•© ìƒíƒœë¥¼ ë¹„íŠ¸ë¡œ í‘œí˜„
- **êµ¬ê°„ DP**: êµ¬ê°„ì„ ì ì§„ì ìœ¼ë¡œ í™•ì¥í•˜ë©° í•´ê²°
- **íŠ¸ë¦¬ DP**: íŠ¸ë¦¬ êµ¬ì¡°ì—ì„œì˜ ë™ì ê³„íšë²•

---

## ğŸ”§ **ê¸°ë³¸ í…œí”Œë¦¿**

### **0-1 ë°°ë‚­ ë¬¸ì œ**
```cpp
// items[i] = {weight, value}
int knapsack01(vector<pair<int, int>>& items, int capacity) {
    int n = items.size();
    vector<vector<int>> dp(n + 1, vector<int>(capacity + 1, 0));
    
    for (int i = 1; i <= n; i++) {
        int weight = items[i-1].first;
        int value = items[i-1].second;
        
        for (int w = 0; w <= capacity; w++) {
            dp[i][w] = dp[i-1][w];  // ì„ íƒí•˜ì§€ ì•ŠëŠ” ê²½ìš°
            
            if (w >= weight) {
                dp[i][w] = max(dp[i][w], dp[i-1][w-weight] + value);
            }
        }
    }
    
    return dp[n][capacity];
}

// ê³µê°„ ìµœì í™” ë²„ì „
int knapsack01Optimized(vector<pair<int, int>>& items, int capacity) {
    vector<int> dp(capacity + 1, 0);
    
    for (auto [weight, value] : items) {
        // ë’¤ì—ì„œë¶€í„° ê°±ì‹  (ì¤‘ë³µ ì‚¬ìš© ë°©ì§€)
        for (int w = capacity; w >= weight; w--) {
            dp[w] = max(dp[w], dp[w - weight] + value);
        }
    }
    
    return dp[capacity];
}
```

### **ë¹„íŠ¸ë§ˆìŠ¤í‚¹ DP**
```cpp
// ì™¸íŒì› ìˆœíšŒ ë¬¸ì œ (TSP)
const int INF = 1e9;

int tsp(vector<vector<int>>& dist) {
    int n = dist.size();
    vector<vector<int>> dp(1 << n, vector<int>(n, INF));
    
    dp[1][0] = 0;  // ì‹œì‘ì ì—ì„œ ì¶œë°œ
    
    for (int mask = 1; mask < (1 << n); mask++) {
        for (int u = 0; u < n; u++) {
            if (!(mask & (1 << u)) || dp[mask][u] == INF) continue;
            
            for (int v = 0; v < n; v++) {
                if (mask & (1 << v)) continue;  // ì´ë¯¸ ë°©ë¬¸
                
                int nextMask = mask | (1 << v);
                dp[nextMask][v] = min(dp[nextMask][v], 
                                     dp[mask][u] + dist[u][v]);
            }
        }
    }
    
    int result = INF;
    int fullMask = (1 << n) - 1;
    
    for (int i = 1; i < n; i++) {
        if (dp[fullMask][i] != INF) {
            result = min(result, dp[fullMask][i] + dist[i][0]);
        }
    }
    
    return result == INF ? -1 : result;
}

// ë¹„íŠ¸ë§ˆìŠ¤í‚¹ ê¸°ë³¸ ì—°ì‚°ë“¤
bool isSet(int mask, int pos) { return mask & (1 << pos); }
int setBit(int mask, int pos) { return mask | (1 << pos); }
int clearBit(int mask, int pos) { return mask & ~(1 << pos); }
int countBits(int mask) { return __builtin_popcount(mask); }
```

### **êµ¬ê°„ DP**
```cpp
// í–‰ë ¬ ê³±ì…ˆ ìˆœì„œ ìµœì í™”
int matrixChainMultiplication(vector<int>& dimensions) {
    int n = dimensions.size() - 1;  // í–‰ë ¬ ê°œìˆ˜
    vector<vector<int>> dp(n, vector<int>(n, 0));
    
    // ê¸¸ì´ë³„ë¡œ ê³„ì‚°
    for (int len = 2; len <= n; len++) {
        for (int i = 0; i <= n - len; i++) {
            int j = i + len - 1;
            dp[i][j] = INF;
            
            for (int k = i; k < j; k++) {
                int cost = dp[i][k] + dp[k+1][j] + 
                          dimensions[i] * dimensions[k+1] * dimensions[j+1];
                dp[i][j] = min(dp[i][j], cost);
            }
        }
    }
    
    return dp[0][n-1];
}

// íŒ°ë¦°ë“œë¡¬ ë¶„í• 
int palindromePartition(string& s) {
    int n = s.length();
    vector<vector<bool>> isPalindrome(n, vector<bool>(n, false));
    vector<int> dp(n + 1, INF);
    
    // íŒ°ë¦°ë“œë¡¬ ì „ì²˜ë¦¬
    for (int i = 0; i < n; i++) {
        isPalindrome[i][i] = true;
    }
    
    for (int len = 2; len <= n; len++) {
        for (int i = 0; i <= n - len; i++) {
            int j = i + len - 1;
            if (s[i] == s[j]) {
                isPalindrome[i][j] = (len == 2) || isPalindrome[i+1][j-1];
            }
        }
    }
    
    dp[0] = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < i; j++) {
            if (isPalindrome[j][i-1]) {
                dp[i] = min(dp[i], dp[j] + 1);
            }
        }
    }
    
    return dp[n];
}
```

### **íŠ¸ë¦¬ DP**
```cpp
// íŠ¸ë¦¬ì—ì„œ ìµœëŒ€ ë…ë¦½ ì§‘í•©
vector<vector<int>> tree;
vector<vector<int>> dp;  // dp[node][0/1] = ì„ íƒX/ì„ íƒO

void treeDFS(int node, int parent) {
    dp[node][0] = 0;  // í˜„ì¬ ë…¸ë“œ ì„ íƒí•˜ì§€ ì•ŠìŒ
    dp[node][1] = 1;  // í˜„ì¬ ë…¸ë“œ ì„ íƒ
    
    for (int child : tree[node]) {
        if (child == parent) continue;
        
        treeDFS(child, node);
        
        dp[node][0] += max(dp[child][0], dp[child][1]);  // ìì‹ì€ ììœ ë¡­ê²Œ
        dp[node][1] += dp[child][0];  // ìì‹ì€ ì„ íƒí•˜ì§€ ì•ŠìŒ
    }
}

int maxIndependentSet(int n) {
    tree.resize(n);
    dp.resize(n, vector<int>(2));
    
    treeDFS(0, -1);
    return max(dp[0][0], dp[0][1]);
}
```

---

## ğŸ’¡ **ê³ ê¸‰ íŒ¨í„´**

### **1. í™•ë¥  DP**
```cpp
// ê¸°ëŒ“ê°’ ê³„ì‚°
double expectedSteps(int n, double p) {
    vector<double> dp(n + 1, 0);
    
    for (int i = n - 1; i >= 0; i--) {
        if (i == n - 1) {
            dp[i] = 1 + (1 - p) * dp[i];  // dp[i] = (1 + (1-p)*dp[i]) / p
            dp[i] = 1 / p;
        } else {
            dp[i] = 1 + p * dp[i + 1] + (1 - p) * dp[i];
            dp[i] = (1 + p * dp[i + 1]) / p;
        }
    }
    
    return dp[0];
}
```

### **2. ë””ì§€í„¸ DP**
```cpp
// ìë¦¿ìˆ˜ DP - íŠ¹ì • ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ìˆ˜ì˜ ê°œìˆ˜
int digitDP(string& num, int pos, int tight, int started, int sum) {
    static map<tuple<int, int, int, int>, int> memo;
    
    if (pos == num.length()) {
        return started ? (sum == 0) : 0;  // ì¡°ê±´ í™•ì¸
    }
    
    auto key = make_tuple(pos, tight, started, sum);
    if (memo.count(key)) return memo[key];
    
    int limit = tight ? (num[pos] - '0') : 9;
    int result = 0;
    
    for (int digit = 0; digit <= limit; digit++) {
        int newTight = tight && (digit == limit);
        int newStarted = started || (digit > 0);
        int newSum = (sum + digit) % MOD;  // ì¡°ê±´ì— ë”°ë¼ ë³€ê²½
        
        result += digitDP(num, pos + 1, newTight, newStarted, newSum);
    }
    
    return memo[key] = result;
}
```

### **3. ìƒíƒœ ì••ì¶• DP**
```cpp
// íƒ€ì¼ë§ ë¬¸ì œ (í”„ë¡œí•„ DP)
vector<vector<int>> memo;

int tiling(int col, int mask, int n, int m) {
    if (col == m) return mask == 0;
    
    if (memo[col][mask] != -1) return memo[col][mask];
    
    return memo[col][mask] = fillColumn(col, mask, 0, 0, n, m);
}

int fillColumn(int col, int mask, int pos, int nextMask, int n, int m) {
    if (pos == n) {
        return tiling(col + 1, nextMask, n, m);
    }
    
    int result = 0;
    
    if (mask & (1 << pos)) {
        // ì´ë¯¸ ì±„ì›Œì§„ ì¹¸
        result += fillColumn(col, mask, pos + 1, nextMask, n, m);
    } else {
        // ì„¸ë¡œ íƒ€ì¼ ë†“ê¸°
        result += fillColumn(col, mask | (1 << pos), pos + 1, 
                           nextMask | (1 << pos), n, m);
        
        // ê°€ë¡œ íƒ€ì¼ ë†“ê¸° (2ì¹¸ ì—°ì†)
        if (pos + 1 < n && !(mask & (1 << (pos + 1)))) {
            result += fillColumn(col, mask | (1 << pos) | (1 << (pos + 1)), 
                               pos + 2, nextMask, n, m);
        }
    }
    
    return result;
}
```

---

## ğŸ” **ì‹¤ì œ ì˜ˆì‹œ**

### **ì˜ˆì‹œ 1: í‰ë²”í•œ ë°°ë‚­ (12865ë²ˆ)**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int N, K;
    cin >> N >> K;
    
    vector<pair<int, int>> items(N);
    for (int i = 0; i < N; i++) {
        cin >> items[i].first >> items[i].second;  // weight, value
    }
    
    vector<int> dp(K + 1, 0);
    
    for (auto [weight, value] : items) {
        for (int w = K; w >= weight; w--) {
            dp[w] = max(dp[w], dp[w - weight] + value);
        }
    }
    
    cout << dp[K] << "\n";
    
    return 0;
}
```

### **ì˜ˆì‹œ 2: ì™¸íŒì› ìˆœíšŒ (2098ë²ˆ)**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

const int INF = 1e9;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    cin >> n;
    
    vector<vector<int>> cost(n, vector<int>(n));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> cost[i][j];
        }
    }
    
    vector<vector<int>> dp(1 << n, vector<int>(n, INF));
    dp[1][0] = 0;  // 0ë²ˆ ë„ì‹œì—ì„œ ì‹œì‘
    
    for (int mask = 1; mask < (1 << n); mask++) {
        for (int u = 0; u < n; u++) {
            if (!(mask & (1 << u)) || dp[mask][u] == INF) continue;
            
            for (int v = 0; v < n; v++) {
                if ((mask & (1 << v)) || cost[u][v] == 0) continue;
                
                int nextMask = mask | (1 << v);
                dp[nextMask][v] = min(dp[nextMask][v], 
                                     dp[mask][u] + cost[u][v]);
            }
        }
    }
    
    int result = INF;
    int fullMask = (1 << n) - 1;
    
    for (int i = 1; i < n; i++) {
        if (dp[fullMask][i] != INF && cost[i][0] != 0) {
            result = min(result, dp[fullMask][i] + cost[i][0]);
        }
    }
    
    cout << result << "\n";
    
    return 0;
}
```

### **ì˜ˆì‹œ 3: ê³„ë‹¨ ìˆ˜ (1562ë²ˆ)**
```cpp
#include <iostream>
#include <vector>

const int MOD = 1000000000;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int N;
    cin >> N;
    
    // dp[ê¸¸ì´][ë§ˆì§€ë§‰ìë¦¬][ë¹„íŠ¸ë§ˆìŠ¤í¬] = ê²½ìš°ì˜ ìˆ˜
    vector<vector<vector<int>>> dp(N + 1, vector<vector<int>>(10, vector<int>(1024, 0)));
    
    // ê¸¸ì´ 1ì¼ ë•Œ ì´ˆê¸°í™” (0ìœ¼ë¡œ ì‹œì‘í•˜ëŠ” ìˆ˜ëŠ” ì œì™¸)
    for (int digit = 1; digit <= 9; digit++) {
        dp[1][digit][1 << digit] = 1;
    }
    
    for (int len = 2; len <= N; len++) {
        for (int last = 0; last <= 9; last++) {
            for (int mask = 0; mask < 1024; mask++) {
                if (dp[len - 1][last][mask] == 0) continue;
                
                // ë‹¤ìŒ ìë¦¬ìˆ˜ í›„ë³´
                vector<int> nextDigits;
                if (last > 0) nextDigits.push_back(last - 1);
                if (last < 9) nextDigits.push_back(last + 1);
                
                for (int next : nextDigits) {
                    int nextMask = mask | (1 << next);
                    dp[len][next][nextMask] = (dp[len][next][nextMask] + dp[len - 1][last][mask]) % MOD;
                }
            }
        }
    }
    
    int result = 0;
    int fullMask = (1 << 10) - 1;  // 0~9 ëª¨ë“  ìˆ«ì ì‚¬ìš©
    
    for (int last = 0; last <= 9; last++) {
        result = (result + dp[N][last][fullMask]) % MOD;
    }
    
    cout << result << "\n";
    
    return 0;
}
```

---

## âš¡ **ìµœì í™” ê¸°ë²•**

### **1. ë©”ëª¨ë¦¬ ìµœì í™”**
```cpp
// ë¡¤ë§ ë°°ì—´ë¡œ ë©”ëª¨ë¦¬ ì ˆì•½
vector<vector<int>> dp(2, vector<int>(n, 0));
int curr = 0, prev = 1;

for (int i = 0; i < m; i++) {
    swap(curr, prev);
    // dp[curr] ê³„ì‚°...
}
```

### **2. ìƒíƒœ ì „ì´ ìµœì í™”**
```cpp
// Convex Hull Trick (CHT)
struct Line {
    long long a, b;
    long long eval(long long x) { return a * x + b; }
};

bool bad(const Line& l1, const Line& l2, const Line& l3) {
    return (l3.b - l1.b) * (l1.a - l2.a) <= (l2.b - l1.b) * (l1.a - l3.a);
}
```

### **3. ë¶„í•  ì •ë³µ ìµœì í™”**
```cpp
// Divide and Conquer Optimization
void compute(int l, int r, int optL, int optR) {
    if (l > r) return;
    
    int mid = (l + r) / 2;
    int optMid = optL;
    
    for (int k = optL; k <= min(mid - 1, optR); k++) {
        if (dp[mid][k] < dp[mid][optMid]) {
            optMid = k;
        }
    }
    
    compute(l, mid - 1, optL, optMid);
    compute(mid + 1, r, optMid, optR);
}
```

---

## ğŸ“ **ê´€ë ¨ ë¬¸ì œ**

### **ë°°ë‚­ DP**
- 12865: í‰ë²”í•œ ë°°ë‚­
- 7579: ì•±
- 2629: ì–‘íŒ”ì €ìš¸

### **ë¹„íŠ¸ë§ˆìŠ¤í‚¹ DP**
- 2098: ì™¸íŒì› ìˆœíšŒ
- 1562: ê³„ë‹¨ ìˆ˜
- 2342: Dance Dance Revolution

### **êµ¬ê°„ DP**
- 11049: í–‰ë ¬ ê³±ì…ˆ ìˆœì„œ
- 2263: íŠ¸ë¦¬ì˜ ìˆœíšŒ
- 1520: ë‚´ë¦¬ë§‰ ê¸¸

### **íŠ¸ë¦¬ DP**
- 2533: ì‚¬íšŒë§ ì„œë¹„ìŠ¤(SNS)
- 15681: íŠ¸ë¦¬ì™€ ì¿¼ë¦¬

---

**ğŸ”‘ í•µì‹¬ í¬ì¸íŠ¸**:
- **ìƒíƒœ ì„¤ê³„**ê°€ ê°€ì¥ ì¤‘ìš”
- **ë©”ëª¨ë¦¬ ìµœì í™”** ê¸°ë²• í™œìš©
- **ë¹„íŠ¸ë§ˆìŠ¤í‚¹**ìœ¼ë¡œ ì§‘í•© ìƒíƒœ í‘œí˜„
- **ì í™”ì‹ ë„ì¶œ** í›„ êµ¬í˜„