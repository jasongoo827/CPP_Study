# 💎 고급 동적계획법

> **난이도**: Gold ~ Platinum  
> **대표 문제**: 12865(평범한 배낭), 2098(외판원 순회), 1562(계단 수)

---

## 🎯 **핵심 개념**

고급 DP는 **복잡한 상태와 전이**를 다루는 동적계획법 기법들입니다:
- **배낭 문제(Knapsack)**: 제한된 용량에서 최적 선택
- **비트마스킹 DP**: 집합 상태를 비트로 표현
- **구간 DP**: 구간을 점진적으로 확장하며 해결
- **트리 DP**: 트리 구조에서의 동적계획법

---

## 🔧 **기본 템플릿**

### **0-1 배낭 문제**
```cpp
// items[i] = {weight, value}
int knapsack01(vector<pair<int, int>>& items, int capacity) {
    int n = items.size();
    vector<vector<int>> dp(n + 1, vector<int>(capacity + 1, 0));
    
    for (int i = 1; i <= n; i++) {
        int weight = items[i-1].first;
        int value = items[i-1].second;
        
        for (int w = 0; w <= capacity; w++) {
            dp[i][w] = dp[i-1][w];  // 선택하지 않는 경우
            
            if (w >= weight) {
                dp[i][w] = max(dp[i][w], dp[i-1][w-weight] + value);
            }
        }
    }
    
    return dp[n][capacity];
}

// 공간 최적화 버전
int knapsack01Optimized(vector<pair<int, int>>& items, int capacity) {
    vector<int> dp(capacity + 1, 0);
    
    for (auto [weight, value] : items) {
        // 뒤에서부터 갱신 (중복 사용 방지)
        for (int w = capacity; w >= weight; w--) {
            dp[w] = max(dp[w], dp[w - weight] + value);
        }
    }
    
    return dp[capacity];
}
```

### **비트마스킹 DP**
```cpp
// 외판원 순회 문제 (TSP)
const int INF = 1e9;

int tsp(vector<vector<int>>& dist) {
    int n = dist.size();
    vector<vector<int>> dp(1 << n, vector<int>(n, INF));
    
    dp[1][0] = 0;  // 시작점에서 출발
    
    for (int mask = 1; mask < (1 << n); mask++) {
        for (int u = 0; u < n; u++) {
            if (!(mask & (1 << u)) || dp[mask][u] == INF) continue;
            
            for (int v = 0; v < n; v++) {
                if (mask & (1 << v)) continue;  // 이미 방문
                
                int nextMask = mask | (1 << v);
                dp[nextMask][v] = min(dp[nextMask][v], 
                                     dp[mask][u] + dist[u][v]);
            }
        }
    }
    
    int result = INF;
    int fullMask = (1 << n) - 1;
    
    for (int i = 1; i < n; i++) {
        if (dp[fullMask][i] != INF) {
            result = min(result, dp[fullMask][i] + dist[i][0]);
        }
    }
    
    return result == INF ? -1 : result;
}

// 비트마스킹 기본 연산들
bool isSet(int mask, int pos) { return mask & (1 << pos); }
int setBit(int mask, int pos) { return mask | (1 << pos); }
int clearBit(int mask, int pos) { return mask & ~(1 << pos); }
int countBits(int mask) { return __builtin_popcount(mask); }
```

### **구간 DP**
```cpp
// 행렬 곱셈 순서 최적화
int matrixChainMultiplication(vector<int>& dimensions) {
    int n = dimensions.size() - 1;  // 행렬 개수
    vector<vector<int>> dp(n, vector<int>(n, 0));
    
    // 길이별로 계산
    for (int len = 2; len <= n; len++) {
        for (int i = 0; i <= n - len; i++) {
            int j = i + len - 1;
            dp[i][j] = INF;
            
            for (int k = i; k < j; k++) {
                int cost = dp[i][k] + dp[k+1][j] + 
                          dimensions[i] * dimensions[k+1] * dimensions[j+1];
                dp[i][j] = min(dp[i][j], cost);
            }
        }
    }
    
    return dp[0][n-1];
}

// 팰린드롬 분할
int palindromePartition(string& s) {
    int n = s.length();
    vector<vector<bool>> isPalindrome(n, vector<bool>(n, false));
    vector<int> dp(n + 1, INF);
    
    // 팰린드롬 전처리
    for (int i = 0; i < n; i++) {
        isPalindrome[i][i] = true;
    }
    
    for (int len = 2; len <= n; len++) {
        for (int i = 0; i <= n - len; i++) {
            int j = i + len - 1;
            if (s[i] == s[j]) {
                isPalindrome[i][j] = (len == 2) || isPalindrome[i+1][j-1];
            }
        }
    }
    
    dp[0] = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < i; j++) {
            if (isPalindrome[j][i-1]) {
                dp[i] = min(dp[i], dp[j] + 1);
            }
        }
    }
    
    return dp[n];
}
```

### **트리 DP**
```cpp
// 트리에서 최대 독립 집합
vector<vector<int>> tree;
vector<vector<int>> dp;  // dp[node][0/1] = 선택X/선택O

void treeDFS(int node, int parent) {
    dp[node][0] = 0;  // 현재 노드 선택하지 않음
    dp[node][1] = 1;  // 현재 노드 선택
    
    for (int child : tree[node]) {
        if (child == parent) continue;
        
        treeDFS(child, node);
        
        dp[node][0] += max(dp[child][0], dp[child][1]);  // 자식은 자유롭게
        dp[node][1] += dp[child][0];  // 자식은 선택하지 않음
    }
}

int maxIndependentSet(int n) {
    tree.resize(n);
    dp.resize(n, vector<int>(2));
    
    treeDFS(0, -1);
    return max(dp[0][0], dp[0][1]);
}
```

---

## 💡 **고급 패턴**

### **1. 확률 DP**
```cpp
// 기댓값 계산
double expectedSteps(int n, double p) {
    vector<double> dp(n + 1, 0);
    
    for (int i = n - 1; i >= 0; i--) {
        if (i == n - 1) {
            dp[i] = 1 + (1 - p) * dp[i];  // dp[i] = (1 + (1-p)*dp[i]) / p
            dp[i] = 1 / p;
        } else {
            dp[i] = 1 + p * dp[i + 1] + (1 - p) * dp[i];
            dp[i] = (1 + p * dp[i + 1]) / p;
        }
    }
    
    return dp[0];
}
```

### **2. 디지털 DP**
```cpp
// 자릿수 DP - 특정 조건을 만족하는 수의 개수
int digitDP(string& num, int pos, int tight, int started, int sum) {
    static map<tuple<int, int, int, int>, int> memo;
    
    if (pos == num.length()) {
        return started ? (sum == 0) : 0;  // 조건 확인
    }
    
    auto key = make_tuple(pos, tight, started, sum);
    if (memo.count(key)) return memo[key];
    
    int limit = tight ? (num[pos] - '0') : 9;
    int result = 0;
    
    for (int digit = 0; digit <= limit; digit++) {
        int newTight = tight && (digit == limit);
        int newStarted = started || (digit > 0);
        int newSum = (sum + digit) % MOD;  // 조건에 따라 변경
        
        result += digitDP(num, pos + 1, newTight, newStarted, newSum);
    }
    
    return memo[key] = result;
}
```

### **3. 상태 압축 DP**
```cpp
// 타일링 문제 (프로필 DP)
vector<vector<int>> memo;

int tiling(int col, int mask, int n, int m) {
    if (col == m) return mask == 0;
    
    if (memo[col][mask] != -1) return memo[col][mask];
    
    return memo[col][mask] = fillColumn(col, mask, 0, 0, n, m);
}

int fillColumn(int col, int mask, int pos, int nextMask, int n, int m) {
    if (pos == n) {
        return tiling(col + 1, nextMask, n, m);
    }
    
    int result = 0;
    
    if (mask & (1 << pos)) {
        // 이미 채워진 칸
        result += fillColumn(col, mask, pos + 1, nextMask, n, m);
    } else {
        // 세로 타일 놓기
        result += fillColumn(col, mask | (1 << pos), pos + 1, 
                           nextMask | (1 << pos), n, m);
        
        // 가로 타일 놓기 (2칸 연속)
        if (pos + 1 < n && !(mask & (1 << (pos + 1)))) {
            result += fillColumn(col, mask | (1 << pos) | (1 << (pos + 1)), 
                               pos + 2, nextMask, n, m);
        }
    }
    
    return result;
}
```

---

## 🔍 **실제 예시**

### **예시 1: 평범한 배낭 (12865번)**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int N, K;
    cin >> N >> K;
    
    vector<pair<int, int>> items(N);
    for (int i = 0; i < N; i++) {
        cin >> items[i].first >> items[i].second;  // weight, value
    }
    
    vector<int> dp(K + 1, 0);
    
    for (auto [weight, value] : items) {
        for (int w = K; w >= weight; w--) {
            dp[w] = max(dp[w], dp[w - weight] + value);
        }
    }
    
    cout << dp[K] << "\n";
    
    return 0;
}
```

### **예시 2: 외판원 순회 (2098번)**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

const int INF = 1e9;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    cin >> n;
    
    vector<vector<int>> cost(n, vector<int>(n));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> cost[i][j];
        }
    }
    
    vector<vector<int>> dp(1 << n, vector<int>(n, INF));
    dp[1][0] = 0;  // 0번 도시에서 시작
    
    for (int mask = 1; mask < (1 << n); mask++) {
        for (int u = 0; u < n; u++) {
            if (!(mask & (1 << u)) || dp[mask][u] == INF) continue;
            
            for (int v = 0; v < n; v++) {
                if ((mask & (1 << v)) || cost[u][v] == 0) continue;
                
                int nextMask = mask | (1 << v);
                dp[nextMask][v] = min(dp[nextMask][v], 
                                     dp[mask][u] + cost[u][v]);
            }
        }
    }
    
    int result = INF;
    int fullMask = (1 << n) - 1;
    
    for (int i = 1; i < n; i++) {
        if (dp[fullMask][i] != INF && cost[i][0] != 0) {
            result = min(result, dp[fullMask][i] + cost[i][0]);
        }
    }
    
    cout << result << "\n";
    
    return 0;
}
```

### **예시 3: 계단 수 (1562번)**
```cpp
#include <iostream>
#include <vector>

const int MOD = 1000000000;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int N;
    cin >> N;
    
    // dp[길이][마지막자리][비트마스크] = 경우의 수
    vector<vector<vector<int>>> dp(N + 1, vector<vector<int>>(10, vector<int>(1024, 0)));
    
    // 길이 1일 때 초기화 (0으로 시작하는 수는 제외)
    for (int digit = 1; digit <= 9; digit++) {
        dp[1][digit][1 << digit] = 1;
    }
    
    for (int len = 2; len <= N; len++) {
        for (int last = 0; last <= 9; last++) {
            for (int mask = 0; mask < 1024; mask++) {
                if (dp[len - 1][last][mask] == 0) continue;
                
                // 다음 자리수 후보
                vector<int> nextDigits;
                if (last > 0) nextDigits.push_back(last - 1);
                if (last < 9) nextDigits.push_back(last + 1);
                
                for (int next : nextDigits) {
                    int nextMask = mask | (1 << next);
                    dp[len][next][nextMask] = (dp[len][next][nextMask] + dp[len - 1][last][mask]) % MOD;
                }
            }
        }
    }
    
    int result = 0;
    int fullMask = (1 << 10) - 1;  // 0~9 모든 숫자 사용
    
    for (int last = 0; last <= 9; last++) {
        result = (result + dp[N][last][fullMask]) % MOD;
    }
    
    cout << result << "\n";
    
    return 0;
}
```

---

## ⚡ **최적화 기법**

### **1. 메모리 최적화**
```cpp
// 롤링 배열로 메모리 절약
vector<vector<int>> dp(2, vector<int>(n, 0));
int curr = 0, prev = 1;

for (int i = 0; i < m; i++) {
    swap(curr, prev);
    // dp[curr] 계산...
}
```

### **2. 상태 전이 최적화**
```cpp
// Convex Hull Trick (CHT)
struct Line {
    long long a, b;
    long long eval(long long x) { return a * x + b; }
};

bool bad(const Line& l1, const Line& l2, const Line& l3) {
    return (l3.b - l1.b) * (l1.a - l2.a) <= (l2.b - l1.b) * (l1.a - l3.a);
}
```

### **3. 분할 정복 최적화**
```cpp
// Divide and Conquer Optimization
void compute(int l, int r, int optL, int optR) {
    if (l > r) return;
    
    int mid = (l + r) / 2;
    int optMid = optL;
    
    for (int k = optL; k <= min(mid - 1, optR); k++) {
        if (dp[mid][k] < dp[mid][optMid]) {
            optMid = k;
        }
    }
    
    compute(l, mid - 1, optL, optMid);
    compute(mid + 1, r, optMid, optR);
}
```

---

## 📝 **관련 문제**

### **배낭 DP**
- 12865: 평범한 배낭
- 7579: 앱
- 2629: 양팔저울

### **비트마스킹 DP**
- 2098: 외판원 순회
- 1562: 계단 수
- 2342: Dance Dance Revolution

### **구간 DP**
- 11049: 행렬 곱셈 순서
- 2263: 트리의 순회
- 1520: 내리막 길

### **트리 DP**
- 2533: 사회망 서비스(SNS)
- 15681: 트리와 쿼리

---

**🔑 핵심 포인트**:
- **상태 설계**가 가장 중요
- **메모리 최적화** 기법 활용
- **비트마스킹**으로 집합 상태 표현
- **점화식 도출** 후 구현