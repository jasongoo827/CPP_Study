# 🌳 트라이 (Trie)

> **난이도**: Gold ~ Platinum  
> **대표 문제**: 5052(전화번호 목록), 14425(문자열 집합), 1033(칵테일)

---

## 🎯 **핵심 개념**

트라이(Trie)는 **문자열을 효율적으로 저장하고 검색**하는 트리 자료구조입니다:
- **접두사 트리**: 공통 접두사를 가진 문자열들이 경로를 공유
- **빠른 검색**: 문자열 길이에 비례하는 O(L) 시간
- **자동완성**: 접두사가 주어졌을 때 가능한 문자열들 찾기
- **사전식 순서**: 트라이 순회로 정렬된 순서 확인

---

## 🔧 **기본 템플릿**

### **기본 트라이 구조**
```cpp
struct TrieNode {
    map<char, TrieNode*> children;  // 또는 TrieNode* children[26];
    bool isEndOfWord;
    int count;  // 이 노드를 지나는 문자열 개수 (선택적)
    
    TrieNode() : isEndOfWord(false), count(0) {}
};

class Trie {
private:
    TrieNode* root;
    
public:
    Trie() {
        root = new TrieNode();
    }
    
    // 문자열 삽입
    void insert(const string& word) {
        TrieNode* curr = root;
        
        for (char c : word) {
            if (curr->children.find(c) == curr->children.end()) {
                curr->children[c] = new TrieNode();
            }
            curr = curr->children[c];
            curr->count++;
        }
        curr->isEndOfWord = true;
    }
    
    // 문자열 검색
    bool search(const string& word) {
        TrieNode* curr = root;
        
        for (char c : word) {
            if (curr->children.find(c) == curr->children.end()) {
                return false;
            }
            curr = curr->children[c];
        }
        return curr->isEndOfWord;
    }
    
    // 접두사 검색
    bool startsWith(const string& prefix) {
        TrieNode* curr = root;
        
        for (char c : prefix) {
            if (curr->children.find(c) == curr->children.end()) {
                return false;
            }
            curr = curr->children[c];
        }
        return true;
    }
    
    // 문자열 삭제
    bool remove(const string& word) {
        return removeHelper(root, word, 0);
    }
    
private:
    bool removeHelper(TrieNode* node, const string& word, int index) {
        if (index == word.length()) {
            if (!node->isEndOfWord) return false;
            node->isEndOfWord = false;
            return node->children.empty();  // 자식이 없으면 삭제 가능
        }
        
        char c = word[index];
        auto it = node->children.find(c);
        if (it == node->children.end()) return false;
        
        TrieNode* child = it->second;
        bool shouldDeleteChild = removeHelper(child, word, index + 1);
        
        if (shouldDeleteChild) {
            node->children.erase(it);
            delete child;
            return !node->isEndOfWord && node->children.empty();
        }
        
        return false;
    }
};
```

### **배열 기반 트라이 (영어 소문자만)**
```cpp
struct TrieNode {
    TrieNode* children[26];
    bool isEndOfWord;
    
    TrieNode() : isEndOfWord(false) {
        fill(children, children + 26, nullptr);
    }
};

class FastTrie {
private:
    TrieNode* root;
    
public:
    FastTrie() {
        root = new TrieNode();
    }
    
    void insert(const string& word) {
        TrieNode* curr = root;
        
        for (char c : word) {
            int index = c - 'a';
            if (!curr->children[index]) {
                curr->children[index] = new TrieNode();
            }
            curr = curr->children[index];
        }
        curr->isEndOfWord = true;
    }
    
    bool search(const string& word) {
        TrieNode* curr = root;
        
        for (char c : word) {
            int index = c - 'a';
            if (!curr->children[index]) {
                return false;
            }
            curr = curr->children[index];
        }
        return curr->isEndOfWord;
    }
    
    // 자동완성 - 접두사로 시작하는 모든 단어 찾기
    vector<string> autoComplete(const string& prefix) {
        vector<string> results;
        TrieNode* curr = root;
        
        // 접두사까지 이동
        for (char c : prefix) {
            int index = c - 'a';
            if (!curr->children[index]) {
                return results;  // 접두사가 존재하지 않음
            }
            curr = curr->children[index];
        }
        
        // DFS로 모든 완성 가능한 단어 찾기
        dfs(curr, prefix, results);
        return results;
    }
    
private:
    void dfs(TrieNode* node, string current, vector<string>& results) {
        if (node->isEndOfWord) {
            results.push_back(current);
        }
        
        for (int i = 0; i < 26; i++) {
            if (node->children[i]) {
                dfs(node->children[i], current + char('a' + i), results);
            }
        }
    }
};
```

---

## 💡 **고급 기법**

### **1. 압축 트라이 (Compressed Trie)**
```cpp
struct CompressedTrieNode {
    map<char, CompressedTrieNode*> children;
    string edge;  // 압축된 문자열
    bool isEndOfWord;
    
    CompressedTrieNode(const string& s = "") : edge(s), isEndOfWord(false) {}
};

class CompressedTrie {
private:
    CompressedTrieNode* root;
    
public:
    CompressedTrie() {
        root = new CompressedTrieNode();
    }
    
    void insert(const string& word) {
        insertHelper(root, word, 0);
    }
    
private:
    void insertHelper(CompressedTrieNode* node, const string& word, int index) {
        if (index == word.length()) {
            node->isEndOfWord = true;
            return;
        }
        
        char c = word[index];
        
        if (node->children.find(c) == node->children.end()) {
            // 새로운 노드 생성 - 남은 문자열 전체를 저장
            string remaining = word.substr(index);
            node->children[c] = new CompressedTrieNode(remaining);
            node->children[c]->isEndOfWord = true;
        } else {
            CompressedTrieNode* child = node->children[c];
            string& edge = child->edge;
            
            // 공통 접두사 길이 찾기
            int commonLen = 0;
            int maxLen = min(edge.length(), word.length() - index);
            
            while (commonLen < maxLen && 
                   edge[commonLen] == word[index + commonLen]) {
                commonLen++;
            }
            
            if (commonLen == edge.length()) {
                // 전체 엣지가 매칭됨 - 계속 진행
                insertHelper(child, word, index + commonLen);
            } else {
                // 엣지를 분할해야 함
                splitEdge(child, commonLen);
                insertHelper(child, word, index + commonLen);
            }
        }
    }
    
    void splitEdge(CompressedTrieNode* node, int splitPoint) {
        string originalEdge = node->edge;
        
        // 새로운 내부 노드 생성
        CompressedTrieNode* newChild = new CompressedTrieNode(originalEdge.substr(splitPoint));
        newChild->children = node->children;
        newChild->isEndOfWord = node->isEndOfWord;
        
        // 기존 노드 수정
        node->edge = originalEdge.substr(0, splitPoint);
        node->children.clear();
        node->children[originalEdge[splitPoint]] = newChild;
        node->isEndOfWord = false;
    }
};
```

### **2. 접미사 트라이**
```cpp
class SuffixTrie {
private:
    TrieNode* root;
    
public:
    SuffixTrie(const string& text) {
        root = new TrieNode();
        buildSuffixTrie(text);
    }
    
    void buildSuffixTrie(const string& text) {
        for (int i = 0; i < text.length(); i++) {
            insertSuffix(text.substr(i), i);
        }
    }
    
    void insertSuffix(const string& suffix, int startIndex) {
        TrieNode* curr = root;
        
        for (char c : suffix) {
            if (curr->children.find(c) == curr->children.end()) {
                curr->children[c] = new TrieNode();
            }
            curr = curr->children[c];
        }
        curr->isEndOfWord = true;
        // 접미사의 시작 인덱스 저장 가능
    }
    
    // 패턴이 원본 문자열에 존재하는지 확인
    bool contains(const string& pattern) {
        TrieNode* curr = root;
        
        for (char c : pattern) {
            if (curr->children.find(c) == curr->children.end()) {
                return false;
            }
            curr = curr->children[c];
        }
        return true;  // 접미사로 존재하면 부분 문자열
    }
};
```

### **3. 비트 트라이 (XOR 최대화)**
```cpp
struct BitTrieNode {
    BitTrieNode* children[2];  // 0과 1
    
    BitTrieNode() {
        children[0] = children[1] = nullptr;
    }
};

class BitTrie {
private:
    BitTrieNode* root;
    static const int MAXBITS = 30;  // int의 비트 수
    
public:
    BitTrie() {
        root = new BitTrieNode();
    }
    
    void insert(int num) {
        BitTrieNode* curr = root;
        
        for (int i = MAXBITS; i >= 0; i--) {
            int bit = (num >> i) & 1;
            if (!curr->children[bit]) {
                curr->children[bit] = new BitTrieNode();
            }
            curr = curr->children[bit];
        }
    }
    
    // num과 XOR했을 때 최댓값을 만드는 수와의 XOR 값 반환
    int findMaxXOR(int num) {
        BitTrieNode* curr = root;
        int maxXOR = 0;
        
        for (int i = MAXBITS; i >= 0; i--) {
            int bit = (num >> i) & 1;
            int toggledBit = 1 - bit;
            
            if (curr->children[toggledBit]) {
                maxXOR |= (1 << i);
                curr = curr->children[toggledBit];
            } else {
                curr = curr->children[bit];
            }
        }
        
        return maxXOR;
    }
};
```

---

## 🔍 **실제 예시**

### **예시 1: 전화번호 목록 (5052번)**
```cpp
#include <iostream>
#include <vector>
#include <string>

struct TrieNode {
    TrieNode* children[10];
    bool isEndOfWord;
    
    TrieNode() : isEndOfWord(false) {
        fill(children, children + 10, nullptr);
    }
};

class Trie {
private:
    TrieNode* root;
    
public:
    Trie() {
        root = new TrieNode();
    }
    
    bool insert(const string& number) {
        TrieNode* curr = root;
        bool isPrefix = false;
        
        for (char c : number) {
            int digit = c - '0';
            
            if (!curr->children[digit]) {
                curr->children[digit] = new TrieNode();
            }
            
            curr = curr->children[digit];
            
            // 중간에 끝나는 번호가 있으면 현재 번호는 그 번호의 접두사
            if (curr->isEndOfWord) {
                isPrefix = true;
            }
        }
        
        curr->isEndOfWord = true;
        
        // 현재 번호가 다른 번호의 접두사인지 확인
        for (int i = 0; i < 10; i++) {
            if (curr->children[i]) {
                isPrefix = true;
                break;
            }
        }
        
        return !isPrefix;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int t;
    cin >> t;
    
    while (t--) {
        int n;
        cin >> n;
        
        vector<string> numbers(n);
        for (int i = 0; i < n; i++) {
            cin >> numbers[i];
        }
        
        Trie trie;
        bool consistent = true;
        
        for (const string& number : numbers) {
            if (!trie.insert(number)) {
                consistent = false;
                break;
            }
        }
        
        cout << (consistent ? "YES" : "NO") << "\n";
    }
    
    return 0;
}
```

### **예시 2: 문자열 집합 (14425번)**
```cpp
#include <iostream>
#include <string>

struct TrieNode {
    TrieNode* children[26];
    bool isEndOfWord;
    
    TrieNode() : isEndOfWord(false) {
        fill(children, children + 26, nullptr);
    }
};

class Trie {
private:
    TrieNode* root;
    
public:
    Trie() {
        root = new TrieNode();
    }
    
    void insert(const string& word) {
        TrieNode* curr = root;
        
        for (char c : word) {
            int index = c - 'a';
            if (!curr->children[index]) {
                curr->children[index] = new TrieNode();
            }
            curr = curr->children[index];
        }
        curr->isEndOfWord = true;
    }
    
    bool search(const string& word) {
        TrieNode* curr = root;
        
        for (char c : word) {
            int index = c - 'a';
            if (!curr->children[index]) {
                return false;
            }
            curr = curr->children[index];
        }
        return curr->isEndOfWord;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, m;
    cin >> n >> m;
    
    Trie trie;
    
    for (int i = 0; i < n; i++) {
        string s;
        cin >> s;
        trie.insert(s);
    }
    
    int count = 0;
    for (int i = 0; i < m; i++) {
        string s;
        cin >> s;
        if (trie.search(s)) {
            count++;
        }
    }
    
    cout << count << "\n";
    
    return 0;
}
```

---

## ⚡ **최적화 기법**

### **1. 메모리 최적화**
```cpp
// 메모리 풀 사용
class MemoryPool {
private:
    vector<TrieNode> pool;
    int index;
    
public:
    MemoryPool(int size) : pool(size), index(0) {}
    
    TrieNode* allocate() {
        return &pool[index++];
    }
};
```

### **2. 압축 최적화**
```cpp
// 리프 노드에서는 남은 문자열을 통째로 저장
struct OptimizedTrieNode {
    map<char, OptimizedTrieNode*> children;
    string suffix;  // 리프에서만 사용
    bool isEndOfWord;
};
```

### **3. 캐시 친화적 구조**
```cpp
// 연속된 메모리 배치
struct CacheFriendlyTrie {
    vector<array<int, 26>> children;  // 인덱스 저장
    vector<bool> isEndOfWord;
    int nodeCount;
    
    int createNode() {
        children.emplace_back();
        isEndOfWord.push_back(false);
        fill(children.back().begin(), children.back().end(), -1);
        return nodeCount++;
    }
};
```

---

## 📊 **시간/공간 복잡도**

### **시간 복잡도**
- **삽입**: O(L) (L: 문자열 길이)
- **검색**: O(L)
- **삭제**: O(L)
- **자동완성**: O(L + K) (K: 결과 문자열들의 총 길이)

### **공간 복잡도**
- **최악**: O(ALPHABET_SIZE × N × L)
- **평균**: 공통 접두사로 인해 크게 절약
- **압축 트라이**: 리프 노드에서 메모리 절약

---

## 📝 **관련 문제**

### **기초**
- 14425: 문자열 집합
- 5052: 전화번호 목록
- 4358: 생태학

### **자동완성**
- 17304: 피보나치 문자열의 개수
- 16906: 새로운 언어 CC

### **비트 트라이**
- 13505: 두 수 XOR
- 21939: 문제 추천 시스템 Version 1

### **고급 응용**
- 1033: 칵테일 (역추적)
- 9202: Boggle (보드 게임)

---

**🔑 핵심 포인트**:
- **공통 접두사** 공유로 메모리 효율성
- **문자열 길이**에 비례하는 빠른 연산
- **자동완성**, **사전 기능** 구현에 최적
- **비트 트라이**로 XOR 최적화 문제 해결