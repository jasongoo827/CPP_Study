# ğŸŒ³ íŠ¸ë¼ì´ (Trie)

> **ë‚œì´ë„**: Gold ~ Platinum  
> **ëŒ€í‘œ ë¬¸ì œ**: 5052(ì „í™”ë²ˆí˜¸ ëª©ë¡), 14425(ë¬¸ìì—´ ì§‘í•©), 1033(ì¹µí…Œì¼)

---

## ğŸ¯ **í•µì‹¬ ê°œë…**

íŠ¸ë¼ì´(Trie)ëŠ” **ë¬¸ìì—´ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì €ì¥í•˜ê³  ê²€ìƒ‰**í•˜ëŠ” íŠ¸ë¦¬ ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤:
- **ì ‘ë‘ì‚¬ íŠ¸ë¦¬**: ê³µí†µ ì ‘ë‘ì‚¬ë¥¼ ê°€ì§„ ë¬¸ìì—´ë“¤ì´ ê²½ë¡œë¥¼ ê³µìœ 
- **ë¹ ë¥¸ ê²€ìƒ‰**: ë¬¸ìì—´ ê¸¸ì´ì— ë¹„ë¡€í•˜ëŠ” O(L) ì‹œê°„
- **ìë™ì™„ì„±**: ì ‘ë‘ì‚¬ê°€ ì£¼ì–´ì¡Œì„ ë•Œ ê°€ëŠ¥í•œ ë¬¸ìì—´ë“¤ ì°¾ê¸°
- **ì‚¬ì „ì‹ ìˆœì„œ**: íŠ¸ë¼ì´ ìˆœíšŒë¡œ ì •ë ¬ëœ ìˆœì„œ í™•ì¸

---

## ğŸ”§ **ê¸°ë³¸ í…œí”Œë¦¿**

### **ê¸°ë³¸ íŠ¸ë¼ì´ êµ¬ì¡°**
```cpp
struct TrieNode {
    map<char, TrieNode*> children;  // ë˜ëŠ” TrieNode* children[26];
    bool isEndOfWord;
    int count;  // ì´ ë…¸ë“œë¥¼ ì§€ë‚˜ëŠ” ë¬¸ìì—´ ê°œìˆ˜ (ì„ íƒì )
    
    TrieNode() : isEndOfWord(false), count(0) {}
};

class Trie {
private:
    TrieNode* root;
    
public:
    Trie() {
        root = new TrieNode();
    }
    
    // ë¬¸ìì—´ ì‚½ì…
    void insert(const string& word) {
        TrieNode* curr = root;
        
        for (char c : word) {
            if (curr->children.find(c) == curr->children.end()) {
                curr->children[c] = new TrieNode();
            }
            curr = curr->children[c];
            curr->count++;
        }
        curr->isEndOfWord = true;
    }
    
    // ë¬¸ìì—´ ê²€ìƒ‰
    bool search(const string& word) {
        TrieNode* curr = root;
        
        for (char c : word) {
            if (curr->children.find(c) == curr->children.end()) {
                return false;
            }
            curr = curr->children[c];
        }
        return curr->isEndOfWord;
    }
    
    // ì ‘ë‘ì‚¬ ê²€ìƒ‰
    bool startsWith(const string& prefix) {
        TrieNode* curr = root;
        
        for (char c : prefix) {
            if (curr->children.find(c) == curr->children.end()) {
                return false;
            }
            curr = curr->children[c];
        }
        return true;
    }
    
    // ë¬¸ìì—´ ì‚­ì œ
    bool remove(const string& word) {
        return removeHelper(root, word, 0);
    }
    
private:
    bool removeHelper(TrieNode* node, const string& word, int index) {
        if (index == word.length()) {
            if (!node->isEndOfWord) return false;
            node->isEndOfWord = false;
            return node->children.empty();  // ìì‹ì´ ì—†ìœ¼ë©´ ì‚­ì œ ê°€ëŠ¥
        }
        
        char c = word[index];
        auto it = node->children.find(c);
        if (it == node->children.end()) return false;
        
        TrieNode* child = it->second;
        bool shouldDeleteChild = removeHelper(child, word, index + 1);
        
        if (shouldDeleteChild) {
            node->children.erase(it);
            delete child;
            return !node->isEndOfWord && node->children.empty();
        }
        
        return false;
    }
};
```

### **ë°°ì—´ ê¸°ë°˜ íŠ¸ë¼ì´ (ì˜ì–´ ì†Œë¬¸ìë§Œ)**
```cpp
struct TrieNode {
    TrieNode* children[26];
    bool isEndOfWord;
    
    TrieNode() : isEndOfWord(false) {
        fill(children, children + 26, nullptr);
    }
};

class FastTrie {
private:
    TrieNode* root;
    
public:
    FastTrie() {
        root = new TrieNode();
    }
    
    void insert(const string& word) {
        TrieNode* curr = root;
        
        for (char c : word) {
            int index = c - 'a';
            if (!curr->children[index]) {
                curr->children[index] = new TrieNode();
            }
            curr = curr->children[index];
        }
        curr->isEndOfWord = true;
    }
    
    bool search(const string& word) {
        TrieNode* curr = root;
        
        for (char c : word) {
            int index = c - 'a';
            if (!curr->children[index]) {
                return false;
            }
            curr = curr->children[index];
        }
        return curr->isEndOfWord;
    }
    
    // ìë™ì™„ì„± - ì ‘ë‘ì‚¬ë¡œ ì‹œì‘í•˜ëŠ” ëª¨ë“  ë‹¨ì–´ ì°¾ê¸°
    vector<string> autoComplete(const string& prefix) {
        vector<string> results;
        TrieNode* curr = root;
        
        // ì ‘ë‘ì‚¬ê¹Œì§€ ì´ë™
        for (char c : prefix) {
            int index = c - 'a';
            if (!curr->children[index]) {
                return results;  // ì ‘ë‘ì‚¬ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŒ
            }
            curr = curr->children[index];
        }
        
        // DFSë¡œ ëª¨ë“  ì™„ì„± ê°€ëŠ¥í•œ ë‹¨ì–´ ì°¾ê¸°
        dfs(curr, prefix, results);
        return results;
    }
    
private:
    void dfs(TrieNode* node, string current, vector<string>& results) {
        if (node->isEndOfWord) {
            results.push_back(current);
        }
        
        for (int i = 0; i < 26; i++) {
            if (node->children[i]) {
                dfs(node->children[i], current + char('a' + i), results);
            }
        }
    }
};
```

---

## ğŸ’¡ **ê³ ê¸‰ ê¸°ë²•**

### **1. ì••ì¶• íŠ¸ë¼ì´ (Compressed Trie)**
```cpp
struct CompressedTrieNode {
    map<char, CompressedTrieNode*> children;
    string edge;  // ì••ì¶•ëœ ë¬¸ìì—´
    bool isEndOfWord;
    
    CompressedTrieNode(const string& s = "") : edge(s), isEndOfWord(false) {}
};

class CompressedTrie {
private:
    CompressedTrieNode* root;
    
public:
    CompressedTrie() {
        root = new CompressedTrieNode();
    }
    
    void insert(const string& word) {
        insertHelper(root, word, 0);
    }
    
private:
    void insertHelper(CompressedTrieNode* node, const string& word, int index) {
        if (index == word.length()) {
            node->isEndOfWord = true;
            return;
        }
        
        char c = word[index];
        
        if (node->children.find(c) == node->children.end()) {
            // ìƒˆë¡œìš´ ë…¸ë“œ ìƒì„± - ë‚¨ì€ ë¬¸ìì—´ ì „ì²´ë¥¼ ì €ì¥
            string remaining = word.substr(index);
            node->children[c] = new CompressedTrieNode(remaining);
            node->children[c]->isEndOfWord = true;
        } else {
            CompressedTrieNode* child = node->children[c];
            string& edge = child->edge;
            
            // ê³µí†µ ì ‘ë‘ì‚¬ ê¸¸ì´ ì°¾ê¸°
            int commonLen = 0;
            int maxLen = min(edge.length(), word.length() - index);
            
            while (commonLen < maxLen && 
                   edge[commonLen] == word[index + commonLen]) {
                commonLen++;
            }
            
            if (commonLen == edge.length()) {
                // ì „ì²´ ì—£ì§€ê°€ ë§¤ì¹­ë¨ - ê³„ì† ì§„í–‰
                insertHelper(child, word, index + commonLen);
            } else {
                // ì—£ì§€ë¥¼ ë¶„í• í•´ì•¼ í•¨
                splitEdge(child, commonLen);
                insertHelper(child, word, index + commonLen);
            }
        }
    }
    
    void splitEdge(CompressedTrieNode* node, int splitPoint) {
        string originalEdge = node->edge;
        
        // ìƒˆë¡œìš´ ë‚´ë¶€ ë…¸ë“œ ìƒì„±
        CompressedTrieNode* newChild = new CompressedTrieNode(originalEdge.substr(splitPoint));
        newChild->children = node->children;
        newChild->isEndOfWord = node->isEndOfWord;
        
        // ê¸°ì¡´ ë…¸ë“œ ìˆ˜ì •
        node->edge = originalEdge.substr(0, splitPoint);
        node->children.clear();
        node->children[originalEdge[splitPoint]] = newChild;
        node->isEndOfWord = false;
    }
};
```

### **2. ì ‘ë¯¸ì‚¬ íŠ¸ë¼ì´**
```cpp
class SuffixTrie {
private:
    TrieNode* root;
    
public:
    SuffixTrie(const string& text) {
        root = new TrieNode();
        buildSuffixTrie(text);
    }
    
    void buildSuffixTrie(const string& text) {
        for (int i = 0; i < text.length(); i++) {
            insertSuffix(text.substr(i), i);
        }
    }
    
    void insertSuffix(const string& suffix, int startIndex) {
        TrieNode* curr = root;
        
        for (char c : suffix) {
            if (curr->children.find(c) == curr->children.end()) {
                curr->children[c] = new TrieNode();
            }
            curr = curr->children[c];
        }
        curr->isEndOfWord = true;
        // ì ‘ë¯¸ì‚¬ì˜ ì‹œì‘ ì¸ë±ìŠ¤ ì €ì¥ ê°€ëŠ¥
    }
    
    // íŒ¨í„´ì´ ì›ë³¸ ë¬¸ìì—´ì— ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
    bool contains(const string& pattern) {
        TrieNode* curr = root;
        
        for (char c : pattern) {
            if (curr->children.find(c) == curr->children.end()) {
                return false;
            }
            curr = curr->children[c];
        }
        return true;  // ì ‘ë¯¸ì‚¬ë¡œ ì¡´ì¬í•˜ë©´ ë¶€ë¶„ ë¬¸ìì—´
    }
};
```

### **3. ë¹„íŠ¸ íŠ¸ë¼ì´ (XOR ìµœëŒ€í™”)**
```cpp
struct BitTrieNode {
    BitTrieNode* children[2];  // 0ê³¼ 1
    
    BitTrieNode() {
        children[0] = children[1] = nullptr;
    }
};

class BitTrie {
private:
    BitTrieNode* root;
    static const int MAXBITS = 30;  // intì˜ ë¹„íŠ¸ ìˆ˜
    
public:
    BitTrie() {
        root = new BitTrieNode();
    }
    
    void insert(int num) {
        BitTrieNode* curr = root;
        
        for (int i = MAXBITS; i >= 0; i--) {
            int bit = (num >> i) & 1;
            if (!curr->children[bit]) {
                curr->children[bit] = new BitTrieNode();
            }
            curr = curr->children[bit];
        }
    }
    
    // numê³¼ XORí–ˆì„ ë•Œ ìµœëŒ“ê°’ì„ ë§Œë“œëŠ” ìˆ˜ì™€ì˜ XOR ê°’ ë°˜í™˜
    int findMaxXOR(int num) {
        BitTrieNode* curr = root;
        int maxXOR = 0;
        
        for (int i = MAXBITS; i >= 0; i--) {
            int bit = (num >> i) & 1;
            int toggledBit = 1 - bit;
            
            if (curr->children[toggledBit]) {
                maxXOR |= (1 << i);
                curr = curr->children[toggledBit];
            } else {
                curr = curr->children[bit];
            }
        }
        
        return maxXOR;
    }
};
```

---

## ğŸ” **ì‹¤ì œ ì˜ˆì‹œ**

### **ì˜ˆì‹œ 1: ì „í™”ë²ˆí˜¸ ëª©ë¡ (5052ë²ˆ)**
```cpp
#include <iostream>
#include <vector>
#include <string>

struct TrieNode {
    TrieNode* children[10];
    bool isEndOfWord;
    
    TrieNode() : isEndOfWord(false) {
        fill(children, children + 10, nullptr);
    }
};

class Trie {
private:
    TrieNode* root;
    
public:
    Trie() {
        root = new TrieNode();
    }
    
    bool insert(const string& number) {
        TrieNode* curr = root;
        bool isPrefix = false;
        
        for (char c : number) {
            int digit = c - '0';
            
            if (!curr->children[digit]) {
                curr->children[digit] = new TrieNode();
            }
            
            curr = curr->children[digit];
            
            // ì¤‘ê°„ì— ëë‚˜ëŠ” ë²ˆí˜¸ê°€ ìˆìœ¼ë©´ í˜„ì¬ ë²ˆí˜¸ëŠ” ê·¸ ë²ˆí˜¸ì˜ ì ‘ë‘ì‚¬
            if (curr->isEndOfWord) {
                isPrefix = true;
            }
        }
        
        curr->isEndOfWord = true;
        
        // í˜„ì¬ ë²ˆí˜¸ê°€ ë‹¤ë¥¸ ë²ˆí˜¸ì˜ ì ‘ë‘ì‚¬ì¸ì§€ í™•ì¸
        for (int i = 0; i < 10; i++) {
            if (curr->children[i]) {
                isPrefix = true;
                break;
            }
        }
        
        return !isPrefix;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int t;
    cin >> t;
    
    while (t--) {
        int n;
        cin >> n;
        
        vector<string> numbers(n);
        for (int i = 0; i < n; i++) {
            cin >> numbers[i];
        }
        
        Trie trie;
        bool consistent = true;
        
        for (const string& number : numbers) {
            if (!trie.insert(number)) {
                consistent = false;
                break;
            }
        }
        
        cout << (consistent ? "YES" : "NO") << "\n";
    }
    
    return 0;
}
```

### **ì˜ˆì‹œ 2: ë¬¸ìì—´ ì§‘í•© (14425ë²ˆ)**
```cpp
#include <iostream>
#include <string>

struct TrieNode {
    TrieNode* children[26];
    bool isEndOfWord;
    
    TrieNode() : isEndOfWord(false) {
        fill(children, children + 26, nullptr);
    }
};

class Trie {
private:
    TrieNode* root;
    
public:
    Trie() {
        root = new TrieNode();
    }
    
    void insert(const string& word) {
        TrieNode* curr = root;
        
        for (char c : word) {
            int index = c - 'a';
            if (!curr->children[index]) {
                curr->children[index] = new TrieNode();
            }
            curr = curr->children[index];
        }
        curr->isEndOfWord = true;
    }
    
    bool search(const string& word) {
        TrieNode* curr = root;
        
        for (char c : word) {
            int index = c - 'a';
            if (!curr->children[index]) {
                return false;
            }
            curr = curr->children[index];
        }
        return curr->isEndOfWord;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, m;
    cin >> n >> m;
    
    Trie trie;
    
    for (int i = 0; i < n; i++) {
        string s;
        cin >> s;
        trie.insert(s);
    }
    
    int count = 0;
    for (int i = 0; i < m; i++) {
        string s;
        cin >> s;
        if (trie.search(s)) {
            count++;
        }
    }
    
    cout << count << "\n";
    
    return 0;
}
```

---

## âš¡ **ìµœì í™” ê¸°ë²•**

### **1. ë©”ëª¨ë¦¬ ìµœì í™”**
```cpp
// ë©”ëª¨ë¦¬ í’€ ì‚¬ìš©
class MemoryPool {
private:
    vector<TrieNode> pool;
    int index;
    
public:
    MemoryPool(int size) : pool(size), index(0) {}
    
    TrieNode* allocate() {
        return &pool[index++];
    }
};
```

### **2. ì••ì¶• ìµœì í™”**
```cpp
// ë¦¬í”„ ë…¸ë“œì—ì„œëŠ” ë‚¨ì€ ë¬¸ìì—´ì„ í†µì§¸ë¡œ ì €ì¥
struct OptimizedTrieNode {
    map<char, OptimizedTrieNode*> children;
    string suffix;  // ë¦¬í”„ì—ì„œë§Œ ì‚¬ìš©
    bool isEndOfWord;
};
```

### **3. ìºì‹œ ì¹œí™”ì  êµ¬ì¡°**
```cpp
// ì—°ì†ëœ ë©”ëª¨ë¦¬ ë°°ì¹˜
struct CacheFriendlyTrie {
    vector<array<int, 26>> children;  // ì¸ë±ìŠ¤ ì €ì¥
    vector<bool> isEndOfWord;
    int nodeCount;
    
    int createNode() {
        children.emplace_back();
        isEndOfWord.push_back(false);
        fill(children.back().begin(), children.back().end(), -1);
        return nodeCount++;
    }
};
```

---

## ğŸ“Š **ì‹œê°„/ê³µê°„ ë³µì¡ë„**

### **ì‹œê°„ ë³µì¡ë„**
- **ì‚½ì…**: O(L) (L: ë¬¸ìì—´ ê¸¸ì´)
- **ê²€ìƒ‰**: O(L)
- **ì‚­ì œ**: O(L)
- **ìë™ì™„ì„±**: O(L + K) (K: ê²°ê³¼ ë¬¸ìì—´ë“¤ì˜ ì´ ê¸¸ì´)

### **ê³µê°„ ë³µì¡ë„**
- **ìµœì•…**: O(ALPHABET_SIZE Ã— N Ã— L)
- **í‰ê· **: ê³µí†µ ì ‘ë‘ì‚¬ë¡œ ì¸í•´ í¬ê²Œ ì ˆì•½
- **ì••ì¶• íŠ¸ë¼ì´**: ë¦¬í”„ ë…¸ë“œì—ì„œ ë©”ëª¨ë¦¬ ì ˆì•½

---

## ğŸ“ **ê´€ë ¨ ë¬¸ì œ**

### **ê¸°ì´ˆ**
- 14425: ë¬¸ìì—´ ì§‘í•©
- 5052: ì „í™”ë²ˆí˜¸ ëª©ë¡
- 4358: ìƒíƒœí•™

### **ìë™ì™„ì„±**
- 17304: í”¼ë³´ë‚˜ì¹˜ ë¬¸ìì—´ì˜ ê°œìˆ˜
- 16906: ìƒˆë¡œìš´ ì–¸ì–´ CC

### **ë¹„íŠ¸ íŠ¸ë¼ì´**
- 13505: ë‘ ìˆ˜ XOR
- 21939: ë¬¸ì œ ì¶”ì²œ ì‹œìŠ¤í…œ Version 1

### **ê³ ê¸‰ ì‘ìš©**
- 1033: ì¹µí…Œì¼ (ì—­ì¶”ì )
- 9202: Boggle (ë³´ë“œ ê²Œì„)

---

**ğŸ”‘ í•µì‹¬ í¬ì¸íŠ¸**:
- **ê³µí†µ ì ‘ë‘ì‚¬** ê³µìœ ë¡œ ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±
- **ë¬¸ìì—´ ê¸¸ì´**ì— ë¹„ë¡€í•˜ëŠ” ë¹ ë¥¸ ì—°ì‚°
- **ìë™ì™„ì„±**, **ì‚¬ì „ ê¸°ëŠ¥** êµ¬í˜„ì— ìµœì 
- **ë¹„íŠ¸ íŠ¸ë¼ì´**ë¡œ XOR ìµœì í™” ë¬¸ì œ í•´ê²°