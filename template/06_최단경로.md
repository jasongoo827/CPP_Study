# ğŸ›£ï¸ ìµœë‹¨ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜

> **ë‚œì´ë„**: Gold ~ Platinum  
> **ëŒ€í‘œ ë¬¸ì œ**: 1753(ìµœë‹¨ê²½ë¡œ), 11404(í”Œë¡œì´ë“œ), 1916(ìµœì†Œë¹„ìš© êµ¬í•˜ê¸°)

---

## ğŸ¯ **í•µì‹¬ ê°œë…**

ìµœë‹¨ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜ì€ **ê·¸ë˜í”„ì—ì„œ ë‘ ì •ì  ê°„ì˜ ìµœë‹¨ê±°ë¦¬**ë¥¼ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤:
- **ë‹¤ìµìŠ¤íŠ¸ë¼(Dijkstra)**: ìŒì´ ì•„ë‹Œ ê°€ì¤‘ì¹˜, ë‹¨ì¼ ì¶œë°œì 
- **í”Œë¡œì´ë“œ-ì›Œì…œ(Floyd-Warshall)**: ëª¨ë“  ìŒ ìµœë‹¨ê²½ë¡œ, ìŒì˜ ê°€ì¤‘ì¹˜ í—ˆìš©
- **ë²¨ë§Œ-í¬ë“œ(Bellman-Ford)**: ìŒì˜ ì‚¬ì´í´ ê°ì§€ ê°€ëŠ¥

---

## ğŸ”§ **ê¸°ë³¸ í…œí”Œë¦¿**

### **ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜**
```cpp
#include <vector>
#include <queue>
#include <limits>

const int INF = 1e9;

// ì¸ì ‘ ë¦¬ìŠ¤íŠ¸: {ë„ì°©ì , ê°€ì¤‘ì¹˜}
vector<int> dijkstra(int start, const vector<vector<pair<int, int>>>& graph) {
    int n = graph.size();
    vector<int> dist(n, INF);
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    
    dist[start] = 0;
    pq.push({0, start});  // {ê±°ë¦¬, ì •ì }
    
    while (!pq.empty()) {
        int d = pq.top().first;
        int u = pq.top().second;
        pq.pop();
        
        if (d > dist[u]) continue;  // ì´ë¯¸ ì²˜ë¦¬ëœ ì •ì 
        
        for (auto [v, weight] : graph[u]) {
            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }
    
    return dist;
}
```

### **í”Œë¡œì´ë“œ-ì›Œì…œ ì•Œê³ ë¦¬ì¦˜**
```cpp
// ëª¨ë“  ìŒ ìµœë‹¨ê²½ë¡œ
vector<vector<int>> floydWarshall(vector<vector<int>>& graph) {
    int n = graph.size();
    vector<vector<int>> dist = graph;
    
    // ì´ˆê¸°í™”: ìê¸° ìì‹ ìœ¼ë¡œì˜ ê±°ë¦¬ëŠ” 0
    for (int i = 0; i < n; i++) {
        dist[i][i] = 0;
    }
    
    // kë¥¼ ê±°ì³ê°€ëŠ” ê²½ë¡œ ê³ ë ¤
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][k] != INF && dist[k][j] != INF) {
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                }
            }
        }
    }
    
    return dist;
}
```

### **ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜**
```cpp
struct Edge {
    int from, to, weight;
};

// ìŒì˜ ì‚¬ì´í´ ê°ì§€ ê°€ëŠ¥
pair<vector<int>, bool> bellmanFord(int start, int n, const vector<Edge>& edges) {
    vector<int> dist(n, INF);
    dist[start] = 0;
    
    // n-1ë²ˆ ì™„í™”
    for (int i = 0; i < n - 1; i++) {
        for (const Edge& edge : edges) {
            if (dist[edge.from] != INF && 
                dist[edge.from] + edge.weight < dist[edge.to]) {
                dist[edge.to] = dist[edge.from] + edge.weight;
            }
        }
    }
    
    // ìŒì˜ ì‚¬ì´í´ í™•ì¸
    bool hasNegativeCycle = false;
    for (const Edge& edge : edges) {
        if (dist[edge.from] != INF && 
            dist[edge.from] + edge.weight < dist[edge.to]) {
            hasNegativeCycle = true;
            break;
        }
    }
    
    return {dist, hasNegativeCycle};
}
```

---

## ğŸ’¡ **ê³ ê¸‰ ê¸°ë²•**

### **1. ì–‘ë°©í–¥ ë‹¤ìµìŠ¤íŠ¸ë¼**
```cpp
// ì‹œì‘ì ê³¼ ëì ì—ì„œ ë™ì‹œì— íƒìƒ‰
pair<int, vector<int>> bidirectionalDijkstra(int start, int end, 
    const vector<vector<pair<int, int>>>& graph, 
    const vector<vector<pair<int, int>>>& reverseGraph) {
    
    int n = graph.size();
    vector<int> distForward(n, INF), distBackward(n, INF);
    vector<bool> visitedForward(n, false), visitedBackward(n, false);
    
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pqForward, pqBackward;
    
    distForward[start] = 0;
    distBackward[end] = 0;
    pqForward.push({0, start});
    pqBackward.push({0, end});
    
    int shortestPath = INF;
    
    while (!pqForward.empty() || !pqBackward.empty()) {
        // Forward search
        if (!pqForward.empty()) {
            auto [d, u] = pqForward.top();
            pqForward.pop();
            
            if (visitedForward[u]) continue;
            visitedForward[u] = true;
            
            if (visitedBackward[u]) {
                shortestPath = min(shortestPath, distForward[u] + distBackward[u]);
            }
            
            for (auto [v, weight] : graph[u]) {
                if (distForward[u] + weight < distForward[v]) {
                    distForward[v] = distForward[u] + weight;
                    pqForward.push({distForward[v], v});
                }
            }
        }
        
        // Backward search
        if (!pqBackward.empty()) {
            auto [d, u] = pqBackward.top();
            pqBackward.pop();
            
            if (visitedBackward[u]) continue;
            visitedBackward[u] = true;
            
            if (visitedForward[u]) {
                shortestPath = min(shortestPath, distForward[u] + distBackward[u]);
            }
            
            for (auto [v, weight] : reverseGraph[u]) {
                if (distBackward[u] + weight < distBackward[v]) {
                    distBackward[v] = distBackward[u] + weight;
                    pqBackward.push({distBackward[v], v});
                }
            }
        }
    }
    
    return {shortestPath, {}};  // ê²½ë¡œ ë³µì› ìƒëµ
}
```

### **2. A* ì•Œê³ ë¦¬ì¦˜ (íœ´ë¦¬ìŠ¤í‹± í™œìš©)**
```cpp
// ëª©í‘œì ê¹Œì§€ì˜ íœ´ë¦¬ìŠ¤í‹± í•¨ìˆ˜
int heuristic(int current, int goal, const vector<pair<int, int>>& coordinates) {
    // ë§¨í•˜íƒ„ ê±°ë¦¬ ë˜ëŠ” ìœ í´ë¦¬ë“œ ê±°ë¦¬
    int dx = abs(coordinates[current].first - coordinates[goal].first);
    int dy = abs(coordinates[current].second - coordinates[goal].second);
    return dx + dy;  // ë§¨í•˜íƒ„ ê±°ë¦¬
}

int astar(int start, int goal, const vector<vector<pair<int, int>>>& graph,
          const vector<pair<int, int>>& coordinates) {
    int n = graph.size();
    vector<int> gScore(n, INF);  // ì‹¤ì œ ê±°ë¦¬
    vector<int> fScore(n, INF);  // g + h (ì¶”ì • ì´ ê±°ë¦¬)
    
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    
    gScore[start] = 0;
    fScore[start] = heuristic(start, goal, coordinates);
    pq.push({fScore[start], start});
    
    while (!pq.empty()) {
        int current = pq.top().second;
        pq.pop();
        
        if (current == goal) {
            return gScore[goal];
        }
        
        for (auto [neighbor, weight] : graph[current]) {
            int tentativeGScore = gScore[current] + weight;
            
            if (tentativeGScore < gScore[neighbor]) {
                gScore[neighbor] = tentativeGScore;
                fScore[neighbor] = gScore[neighbor] + heuristic(neighbor, goal, coordinates);
                pq.push({fScore[neighbor], neighbor});
            }
        }
    }
    
    return INF;  // ê²½ë¡œ ì—†ìŒ
}
```

---

## ğŸ” **ì‹¤ì œ ì˜ˆì‹œ**

### **ì˜ˆì‹œ 1: ìµœë‹¨ê²½ë¡œ (1753ë²ˆ)**
```cpp
#include <iostream>
#include <vector>
#include <queue>

const int INF = 1e9;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int V, E, K;
    cin >> V >> E >> K;
    K--;  // 0-based ì¸ë±ìŠ¤
    
    vector<vector<pair<int, int>>> graph(V);
    
    for (int i = 0; i < E; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        u--; v--;  // 0-based ì¸ë±ìŠ¤
        graph[u].push_back({v, w});
    }
    
    vector<int> dist(V, INF);
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    
    dist[K] = 0;
    pq.push({0, K});
    
    while (!pq.empty()) {
        int d = pq.top().first;
        int u = pq.top().second;
        pq.pop();
        
        if (d > dist[u]) continue;
        
        for (auto [v, weight] : graph[u]) {
            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }
    
    for (int i = 0; i < V; i++) {
        if (dist[i] == INF) {
            cout << "INF\n";
        } else {
            cout << dist[i] << "\n";
        }
    }
    
    return 0;
}
```

### **ì˜ˆì‹œ 2: í”Œë¡œì´ë“œ (11404ë²ˆ)**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

const int INF = 1e9;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, m;
    cin >> n >> m;
    
    vector<vector<int>> dist(n, vector<int>(n, INF));
    
    // ìê¸° ìì‹ ìœ¼ë¡œì˜ ê±°ë¦¬ëŠ” 0
    for (int i = 0; i < n; i++) {
        dist[i][i] = 0;
    }
    
    for (int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        a--; b--;  // 0-based ì¸ë±ìŠ¤
        
        // ê°™ì€ ê°„ì„ ì´ ì—¬ëŸ¬ ê°œ ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ìµœì†Ÿê°’ ì„ íƒ
        dist[a][b] = min(dist[a][b], c);
    }
    
    // í”Œë¡œì´ë“œ-ì›Œì…œ
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][k] != INF && dist[k][j] != INF) {
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                }
            }
        }
    }
    
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (dist[i][j] == INF) {
                cout << 0 << " ";
            } else {
                cout << dist[i][j] << " ";
            }
        }
        cout << "\n";
    }
    
    return 0;
}
```

---

## âš¡ **ìµœì í™” íŒ**

### **1. ë‹¤ìµìŠ¤íŠ¸ë¼ ìµœì í™”**
```cpp
// ìš°ì„ ìˆœìœ„ í ëŒ€ì‹  ì…‹ ì‚¬ìš© (ì‚­ì œ ê°€ëŠ¥)
set<pair<int, int>> pq;  // {ê±°ë¦¬, ì •ì }

// ë” ì§§ì€ ê²½ë¡œ ë°œê²¬ ì‹œ ê¸°ì¡´ í•­ëª© ì‚­ì œ
auto it = pq.find({dist[v], v});
if (it != pq.end()) {
    pq.erase(it);
}
pq.insert({dist[v], v});
```

### **2. ë©”ëª¨ë¦¬ ìµœì í™”**
```cpp
// ì¸ì ‘ í–‰ë ¬ ëŒ€ì‹  ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ì‚¬ìš©
vector<vector<pair<int, int>>> graph(n);  // í¬ì†Œ ê·¸ë˜í”„ì— ìœ ë¦¬

// í”Œë¡œì´ë“œ-ì›Œì…œì—ì„œ 3ì°¨ì› ë°°ì—´ ëŒ€ì‹  2ì°¨ì› ë°°ì—´ ì¬ì‚¬ìš©
// dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
```

### **3. ê²½ë¡œ ë³µì›**
```cpp
vector<int> reconstructPath(int start, int end, const vector<int>& parent) {
    vector<int> path;
    for (int at = end; at != -1; at = parent[at]) {
        path.push_back(at);
    }
    reverse(path.begin(), path.end());
    
    return path[0] == start ? path : vector<int>();  // ê²½ë¡œ ì¡´ì¬í•˜ì§€ ì•ŠìŒ
}
```

---

## ğŸ“Š **ì‹œê°„/ê³µê°„ ë³µì¡ë„**

### **ë‹¤ìµìŠ¤íŠ¸ë¼**
- **ì‹œê°„**: O((V + E) log V) (ìš°ì„ ìˆœìœ„ í ì‚¬ìš©)
- **ê³µê°„**: O(V + E)

### **í”Œë¡œì´ë“œ-ì›Œì…œ**
- **ì‹œê°„**: O(VÂ³)
- **ê³µê°„**: O(VÂ²)

### **ë²¨ë§Œ-í¬ë“œ**
- **ì‹œê°„**: O(VE)
- **ê³µê°„**: O(V)

---

## ğŸ“ **ê´€ë ¨ ë¬¸ì œ**

### **ë‹¤ìµìŠ¤íŠ¸ë¼**
- 1753: ìµœë‹¨ê²½ë¡œ
- 1916: ìµœì†Œë¹„ìš© êµ¬í•˜ê¸°
- 1504: íŠ¹ì •í•œ ìµœë‹¨ ê²½ë¡œ

### **í”Œë¡œì´ë“œ-ì›Œì…œ**
- 11404: í”Œë¡œì´ë“œ
- 2458: í‚¤ ìˆœì„œ
- 1389: ì¼€ë¹ˆ ë² ì´ì»¨ì˜ 6ë‹¨ê³„ ë²•ì¹™

### **ë²¨ë§Œ-í¬ë“œ**
- 11657: íƒ€ì„ë¨¸ì‹ 
- 1738: ê³¨ëª©ê¸¸

### **ê³ ê¸‰ ì‘ìš©**
- 1261: ì•Œê³ ìŠ¤íŒŸ (0-1 BFS)
- 5719: ê±°ì˜ ìµœë‹¨ ê²½ë¡œ

---

**ğŸ”‘ í•µì‹¬ í¬ì¸íŠ¸**:
- **ë‹¤ìµìŠ¤íŠ¸ë¼**: ìŒì´ ì•„ë‹Œ ê°€ì¤‘ì¹˜, ë‹¨ì¼ ì¶œë°œì 
- **í”Œë¡œì´ë“œ-ì›Œì…œ**: ëª¨ë“  ìŒ, ì‘ì€ ê·¸ë˜í”„
- **ë²¨ë§Œ-í¬ë“œ**: ìŒì˜ ì‚¬ì´í´ ê°ì§€
- **ìš°ì„ ìˆœìœ„ í** ìµœì í™” í•„ìˆ˜