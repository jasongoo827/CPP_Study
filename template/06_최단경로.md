# 🛣️ 최단경로 알고리즘

> **난이도**: Gold ~ Platinum  
> **대표 문제**: 1753(최단경로), 11404(플로이드), 1916(최소비용 구하기)

---

## 🎯 **핵심 개념**

최단경로 알고리즘은 **그래프에서 두 정점 간의 최단거리**를 찾는 알고리즘입니다:
- **다익스트라(Dijkstra)**: 음이 아닌 가중치, 단일 출발점
- **플로이드-워셜(Floyd-Warshall)**: 모든 쌍 최단경로, 음의 가중치 허용
- **벨만-포드(Bellman-Ford)**: 음의 사이클 감지 가능

---

## 🔧 **기본 템플릿**

### **다익스트라 알고리즘**
```cpp
#include <vector>
#include <queue>
#include <limits>

const int INF = 1e9;

// 인접 리스트: {도착점, 가중치}
vector<int> dijkstra(int start, const vector<vector<pair<int, int>>>& graph) {
    int n = graph.size();
    vector<int> dist(n, INF);
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    
    dist[start] = 0;
    pq.push({0, start});  // {거리, 정점}
    
    while (!pq.empty()) {
        int d = pq.top().first;
        int u = pq.top().second;
        pq.pop();
        
        if (d > dist[u]) continue;  // 이미 처리된 정점
        
        for (auto [v, weight] : graph[u]) {
            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }
    
    return dist;
}
```

### **플로이드-워셜 알고리즘**
```cpp
// 모든 쌍 최단경로
vector<vector<int>> floydWarshall(vector<vector<int>>& graph) {
    int n = graph.size();
    vector<vector<int>> dist = graph;
    
    // 초기화: 자기 자신으로의 거리는 0
    for (int i = 0; i < n; i++) {
        dist[i][i] = 0;
    }
    
    // k를 거쳐가는 경로 고려
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][k] != INF && dist[k][j] != INF) {
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                }
            }
        }
    }
    
    return dist;
}
```

### **벨만-포드 알고리즘**
```cpp
struct Edge {
    int from, to, weight;
};

// 음의 사이클 감지 가능
pair<vector<int>, bool> bellmanFord(int start, int n, const vector<Edge>& edges) {
    vector<int> dist(n, INF);
    dist[start] = 0;
    
    // n-1번 완화
    for (int i = 0; i < n - 1; i++) {
        for (const Edge& edge : edges) {
            if (dist[edge.from] != INF && 
                dist[edge.from] + edge.weight < dist[edge.to]) {
                dist[edge.to] = dist[edge.from] + edge.weight;
            }
        }
    }
    
    // 음의 사이클 확인
    bool hasNegativeCycle = false;
    for (const Edge& edge : edges) {
        if (dist[edge.from] != INF && 
            dist[edge.from] + edge.weight < dist[edge.to]) {
            hasNegativeCycle = true;
            break;
        }
    }
    
    return {dist, hasNegativeCycle};
}
```

---

## 💡 **고급 기법**

### **1. 양방향 다익스트라**
```cpp
// 시작점과 끝점에서 동시에 탐색
pair<int, vector<int>> bidirectionalDijkstra(int start, int end, 
    const vector<vector<pair<int, int>>>& graph, 
    const vector<vector<pair<int, int>>>& reverseGraph) {
    
    int n = graph.size();
    vector<int> distForward(n, INF), distBackward(n, INF);
    vector<bool> visitedForward(n, false), visitedBackward(n, false);
    
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pqForward, pqBackward;
    
    distForward[start] = 0;
    distBackward[end] = 0;
    pqForward.push({0, start});
    pqBackward.push({0, end});
    
    int shortestPath = INF;
    
    while (!pqForward.empty() || !pqBackward.empty()) {
        // Forward search
        if (!pqForward.empty()) {
            auto [d, u] = pqForward.top();
            pqForward.pop();
            
            if (visitedForward[u]) continue;
            visitedForward[u] = true;
            
            if (visitedBackward[u]) {
                shortestPath = min(shortestPath, distForward[u] + distBackward[u]);
            }
            
            for (auto [v, weight] : graph[u]) {
                if (distForward[u] + weight < distForward[v]) {
                    distForward[v] = distForward[u] + weight;
                    pqForward.push({distForward[v], v});
                }
            }
        }
        
        // Backward search
        if (!pqBackward.empty()) {
            auto [d, u] = pqBackward.top();
            pqBackward.pop();
            
            if (visitedBackward[u]) continue;
            visitedBackward[u] = true;
            
            if (visitedForward[u]) {
                shortestPath = min(shortestPath, distForward[u] + distBackward[u]);
            }
            
            for (auto [v, weight] : reverseGraph[u]) {
                if (distBackward[u] + weight < distBackward[v]) {
                    distBackward[v] = distBackward[u] + weight;
                    pqBackward.push({distBackward[v], v});
                }
            }
        }
    }
    
    return {shortestPath, {}};  // 경로 복원 생략
}
```

### **2. A* 알고리즘 (휴리스틱 활용)**
```cpp
// 목표점까지의 휴리스틱 함수
int heuristic(int current, int goal, const vector<pair<int, int>>& coordinates) {
    // 맨하탄 거리 또는 유클리드 거리
    int dx = abs(coordinates[current].first - coordinates[goal].first);
    int dy = abs(coordinates[current].second - coordinates[goal].second);
    return dx + dy;  // 맨하탄 거리
}

int astar(int start, int goal, const vector<vector<pair<int, int>>>& graph,
          const vector<pair<int, int>>& coordinates) {
    int n = graph.size();
    vector<int> gScore(n, INF);  // 실제 거리
    vector<int> fScore(n, INF);  // g + h (추정 총 거리)
    
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    
    gScore[start] = 0;
    fScore[start] = heuristic(start, goal, coordinates);
    pq.push({fScore[start], start});
    
    while (!pq.empty()) {
        int current = pq.top().second;
        pq.pop();
        
        if (current == goal) {
            return gScore[goal];
        }
        
        for (auto [neighbor, weight] : graph[current]) {
            int tentativeGScore = gScore[current] + weight;
            
            if (tentativeGScore < gScore[neighbor]) {
                gScore[neighbor] = tentativeGScore;
                fScore[neighbor] = gScore[neighbor] + heuristic(neighbor, goal, coordinates);
                pq.push({fScore[neighbor], neighbor});
            }
        }
    }
    
    return INF;  // 경로 없음
}
```

---

## 🔍 **실제 예시**

### **예시 1: 최단경로 (1753번)**
```cpp
#include <iostream>
#include <vector>
#include <queue>

const int INF = 1e9;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int V, E, K;
    cin >> V >> E >> K;
    K--;  // 0-based 인덱스
    
    vector<vector<pair<int, int>>> graph(V);
    
    for (int i = 0; i < E; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        u--; v--;  // 0-based 인덱스
        graph[u].push_back({v, w});
    }
    
    vector<int> dist(V, INF);
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    
    dist[K] = 0;
    pq.push({0, K});
    
    while (!pq.empty()) {
        int d = pq.top().first;
        int u = pq.top().second;
        pq.pop();
        
        if (d > dist[u]) continue;
        
        for (auto [v, weight] : graph[u]) {
            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }
    
    for (int i = 0; i < V; i++) {
        if (dist[i] == INF) {
            cout << "INF\n";
        } else {
            cout << dist[i] << "\n";
        }
    }
    
    return 0;
}
```

### **예시 2: 플로이드 (11404번)**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

const int INF = 1e9;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, m;
    cin >> n >> m;
    
    vector<vector<int>> dist(n, vector<int>(n, INF));
    
    // 자기 자신으로의 거리는 0
    for (int i = 0; i < n; i++) {
        dist[i][i] = 0;
    }
    
    for (int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        a--; b--;  // 0-based 인덱스
        
        // 같은 간선이 여러 개 있을 수 있으므로 최솟값 선택
        dist[a][b] = min(dist[a][b], c);
    }
    
    // 플로이드-워셜
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][k] != INF && dist[k][j] != INF) {
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                }
            }
        }
    }
    
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (dist[i][j] == INF) {
                cout << 0 << " ";
            } else {
                cout << dist[i][j] << " ";
            }
        }
        cout << "\n";
    }
    
    return 0;
}
```

---

## ⚡ **최적화 팁**

### **1. 다익스트라 최적화**
```cpp
// 우선순위 큐 대신 셋 사용 (삭제 가능)
set<pair<int, int>> pq;  // {거리, 정점}

// 더 짧은 경로 발견 시 기존 항목 삭제
auto it = pq.find({dist[v], v});
if (it != pq.end()) {
    pq.erase(it);
}
pq.insert({dist[v], v});
```

### **2. 메모리 최적화**
```cpp
// 인접 행렬 대신 인접 리스트 사용
vector<vector<pair<int, int>>> graph(n);  // 희소 그래프에 유리

// 플로이드-워셜에서 3차원 배열 대신 2차원 배열 재사용
// dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
```

### **3. 경로 복원**
```cpp
vector<int> reconstructPath(int start, int end, const vector<int>& parent) {
    vector<int> path;
    for (int at = end; at != -1; at = parent[at]) {
        path.push_back(at);
    }
    reverse(path.begin(), path.end());
    
    return path[0] == start ? path : vector<int>();  // 경로 존재하지 않음
}
```

---

## 📊 **시간/공간 복잡도**

### **다익스트라**
- **시간**: O((V + E) log V) (우선순위 큐 사용)
- **공간**: O(V + E)

### **플로이드-워셜**
- **시간**: O(V³)
- **공간**: O(V²)

### **벨만-포드**
- **시간**: O(VE)
- **공간**: O(V)

---

## 📝 **관련 문제**

### **다익스트라**
- 1753: 최단경로
- 1916: 최소비용 구하기
- 1504: 특정한 최단 경로

### **플로이드-워셜**
- 11404: 플로이드
- 2458: 키 순서
- 1389: 케빈 베이컨의 6단계 법칙

### **벨만-포드**
- 11657: 타임머신
- 1738: 골목길

### **고급 응용**
- 1261: 알고스팟 (0-1 BFS)
- 5719: 거의 최단 경로

---

**🔑 핵심 포인트**:
- **다익스트라**: 음이 아닌 가중치, 단일 출발점
- **플로이드-워셜**: 모든 쌍, 작은 그래프
- **벨만-포드**: 음의 사이클 감지
- **우선순위 큐** 최적화 필수