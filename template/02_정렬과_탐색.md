# 📊 정렬과 탐색

> **난이도**: Silver  
> **대표 문제**: 10816(숫자 카드 2), 1920(수 찾기), 2470(두 용액)

---

## 🎯 **핵심 개념**

정렬과 탐색은 알고리즘의 기본기입니다:
- **정렬**: 데이터를 특정 순서로 배열하여 탐색을 효율적으로 만듦
- **이분 탐색**: 정렬된 데이터에서 O(log n) 시간에 탐색
- **투 포인터**: 정렬된 배열에서 두 포인터를 이용한 효율적 탐색
- **해시**: O(1) 평균 시간으로 빠른 검색

---

## 🔧 **기본 템플릿**

### **이분 탐색 (Binary Search)**
```cpp
#include <algorithm>

// 기본 이분 탐색 - 값이 존재하는지 확인
bool binarySearch(vector<int>& arr, int target) {
    sort(arr.begin(), arr.end());
    
    int left = 0, right = arr.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;  // 오버플로우 방지
        
        if (arr[mid] == target) {
            return true;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return false;
}

// STL 활용
bool exists = binary_search(arr.begin(), arr.end(), target);
int lowerIdx = lower_bound(arr.begin(), arr.end(), target) - arr.begin();
int upperIdx = upper_bound(arr.begin(), arr.end(), target) - arr.begin();
int count = upperIdx - lowerIdx;  // target의 개수
```

### **투 포인터 (Two Pointers)**
```cpp
// 두 수의 합이 target인 쌍 찾기
vector<pair<int, int>> twoSum(vector<int>& arr, int target) {
    sort(arr.begin(), arr.end());
    
    vector<pair<int, int>> result;
    int left = 0, right = arr.size() - 1;
    
    while (left < right) {
        int sum = arr[left] + arr[right];
        
        if (sum == target) {
            result.push_back({arr[left], arr[right]});
            left++;
            right--;
        } else if (sum < target) {
            left++;
        } else {
            right--;
        }
    }
    
    return result;
}

// 부분합이 target 이상인 최단 구간
int shortestSubarray(vector<int>& arr, int target) {
    int left = 0, sum = 0;
    int minLength = INT_MAX;
    
    for (int right = 0; right < arr.size(); right++) {
        sum += arr[right];
        
        while (sum >= target) {
            minLength = min(minLength, right - left + 1);
            sum -= arr[left++];
        }
    }
    
    return minLength == INT_MAX ? 0 : minLength;
}
```

### **해시맵 활용**
```cpp
#include <unordered_map>
#include <map>

// 빈도 카운팅
unordered_map<int, int> countFrequency(const vector<int>& arr) {
    unordered_map<int, int> freq;
    for (int x : arr) {
        freq[x]++;
    }
    return freq;
}

// 두 수의 합 (해시맵 버전)
vector<int> twoSumHash(vector<int>& nums, int target) {
    unordered_map<int, int> map;
    
    for (int i = 0; i < nums.size(); i++) {
        int complement = target - nums[i];
        if (map.find(complement) != map.end()) {
            return {map[complement], i};
        }
        map[nums[i]] = i;
    }
    
    return {};
}
```

---

## 💡 **풀이 패턴**

### **1. 이분 탐색 응용**
```cpp
// 매개변수 탐색 - 조건을 만족하는 최솟값/최댓값 찾기
bool isPossible(int mid, const vector<int>& arr, int condition) {
    // mid가 답이 될 수 있는지 확인하는 함수
    // 구체적인 구현은 문제에 따라 달라짐
    return true;  // 예시
}

int parametricSearch(const vector<int>& arr, int left, int right) {
    int answer = -1;
    
    while (left <= right) {
        int mid = (left + right) / 2;
        
        if (isPossible(mid, arr, 0)) {
            answer = mid;
            right = mid - 1;  // 더 작은 값도 가능한지 확인
        } else {
            left = mid + 1;   // 더 큰 값 필요
        }
    }
    
    return answer;
}
```

### **2. 좌표 압축**
```cpp
// 큰 좌표값들을 작은 범위로 압축
vector<int> coordinateCompression(vector<int>& coords) {
    vector<int> sorted_coords = coords;
    sort(sorted_coords.begin(), sorted_coords.end());
    sorted_coords.erase(unique(sorted_coords.begin(), sorted_coords.end()), 
                       sorted_coords.end());
    
    // 원본 좌표들을 압축된 인덱스로 변환
    for (int& coord : coords) {
        coord = lower_bound(sorted_coords.begin(), sorted_coords.end(), coord) 
                - sorted_coords.begin();
    }
    
    return coords;
}
```

### **3. 정렬 기준 커스터마이징**
```cpp
struct Student {
    string name;
    int age;
    int score;
};

// 커스텀 비교 함수
bool compareStudents(const Student& a, const Student& b) {
    if (a.score != b.score) return a.score > b.score;  // 점수 높은 순
    if (a.age != b.age) return a.age < b.age;          // 나이 낮은 순
    return a.name < b.name;                            // 이름 사전순
}

// 람다 함수 사용
sort(students.begin(), students.end(), [](const Student& a, const Student& b) {
    return a.score > b.score;
});

// 여러 조건 정렬
sort(students.begin(), students.end(), [](const Student& a, const Student& b) {
    return make_tuple(-a.score, a.age, a.name) < 
           make_tuple(-b.score, b.age, b.name);
});
```

---

## 🔍 **실제 예시**

### **예시 1: 숫자 카드 2 (10816번)**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, m;
    cin >> n;
    
    vector<int> cards(n);
    for (int i = 0; i < n; i++) {
        cin >> cards[i];
    }
    
    sort(cards.begin(), cards.end());
    
    cin >> m;
    for (int i = 0; i < m; i++) {
        int target;
        cin >> target;
        
        int count = upper_bound(cards.begin(), cards.end(), target) - 
                   lower_bound(cards.begin(), cards.end(), target);
        
        cout << count << " ";
    }
    
    return 0;
}
```

### **예시 2: 두 용액 (2470번)**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    cin >> n;
    
    vector<int> solutions(n);
    for (int i = 0; i < n; i++) {
        cin >> solutions[i];
    }
    
    sort(solutions.begin(), solutions.end());
    
    int left = 0, right = n - 1;
    int bestSum = solutions[left] + solutions[right];
    int ansLeft = left, ansRight = right;
    
    while (left < right) {
        int sum = solutions[left] + solutions[right];
        
        if (abs(sum) < abs(bestSum)) {
            bestSum = sum;
            ansLeft = left;
            ansRight = right;
        }
        
        if (sum < 0) {
            left++;
        } else {
            right--;
        }
    }
    
    cout << solutions[ansLeft] << " " << solutions[ansRight] << "\n";
    
    return 0;
}
```

### **예시 3: 나이순 정렬 (10814번)**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>

struct Member {
    int age;
    string name;
    int order;  // 입력 순서
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    cin >> n;
    
    vector<Member> members(n);
    for (int i = 0; i < n; i++) {
        cin >> members[i].age >> members[i].name;
        members[i].order = i;
    }
    
    // 안정 정렬을 위해 나이 -> 입력 순서 순으로 정렬
    sort(members.begin(), members.end(), [](const Member& a, const Member& b) {
        if (a.age != b.age) return a.age < b.age;
        return a.order < b.order;  // 같은 나이면 입력 순서대로
    });
    
    for (const Member& member : members) {
        cout << member.age << " " << member.name << "\n";
    }
    
    return 0;
}
```

---

## ⚡ **최적화 팁**

### **1. 정렬 최적화**
```cpp
// 이미 부분적으로 정렬된 경우
if (is_sorted(arr.begin(), arr.end())) {
    // 이미 정렬됨, 추가 정렬 불필요
}

// 부분 정렬 - 상위 k개만 필요한 경우
partial_sort(arr.begin(), arr.begin() + k, arr.end());

// nth_element - k번째 요소만 올바른 위치에
nth_element(arr.begin(), arr.begin() + k, arr.end());
```

### **2. 이분 탐색 최적화**
```cpp
// 오버플로우 방지
int mid = left + (right - left) / 2;

// 실수형 이분 탐색
double binarySearchDouble(double left, double right, double target) {
    const double EPS = 1e-9;
    
    while (right - left > EPS) {
        double mid = (left + right) / 2.0;
        
        if (f(mid) < target) {
            left = mid;
        } else {
            right = mid;
        }
    }
    
    return (left + right) / 2.0;
}
```

### **3. 해시 최적화**
```cpp
// unordered_map vs map
unordered_map<int, int> hashMap;  // O(1) 평균, O(n) 최악
map<int, int> treeMap;           // O(log n) 보장

// 충돌 최소화를 위한 커스텀 해시
struct CustomHash {
    size_t operator()(const pair<int, int>& p) const {
        return hash<int>()(p.first) ^ (hash<int>()(p.second) << 1);
    }
};

unordered_map<pair<int, int>, int, CustomHash> customHashMap;
```

---

## 📝 **관련 문제**

### **이분 탐색**
- 1920: 수 찾기
- 10816: 숫자 카드 2  
- 1654: 랜선 자르기
- 2512: 예산

### **투 포인터**
- 2470: 두 용액
- 2003: 수들의 합 2
- 1806: 부분합
- 2473: 세 용액

### **정렬**
- 10814: 나이순 정렬
- 11650: 좌표 정렬하기
- 1181: 단어 정렬
- 11399: ATM

### **해시**
- 1764: 듣보잡
- 17219: 비밀번호 찾기
- 9375: 패션왕 신해빈

---

**🔑 핵심 포인트**:
- **정렬된 데이터**에서는 이분 탐색으로 O(log n) 검색
- **투 포인터**는 O(n)으로 두 개 조건 만족하는 쌍 찾기
- **해시맵**으로 O(1) 빠른 검색 (평균)
- **STL 함수들** 적극 활용하기