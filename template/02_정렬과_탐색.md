# ğŸ“Š ì •ë ¬ê³¼ íƒìƒ‰

> **ë‚œì´ë„**: Silver  
> **ëŒ€í‘œ ë¬¸ì œ**: 10816(ìˆ«ì ì¹´ë“œ 2), 1920(ìˆ˜ ì°¾ê¸°), 2470(ë‘ ìš©ì•¡)

---

## ğŸ¯ **í•µì‹¬ ê°œë…**

ì •ë ¬ê³¼ íƒìƒ‰ì€ ì•Œê³ ë¦¬ì¦˜ì˜ ê¸°ë³¸ê¸°ì…ë‹ˆë‹¤:
- **ì •ë ¬**: ë°ì´í„°ë¥¼ íŠ¹ì • ìˆœì„œë¡œ ë°°ì—´í•˜ì—¬ íƒìƒ‰ì„ íš¨ìœ¨ì ìœ¼ë¡œ ë§Œë“¦
- **ì´ë¶„ íƒìƒ‰**: ì •ë ¬ëœ ë°ì´í„°ì—ì„œ O(log n) ì‹œê°„ì— íƒìƒ‰
- **íˆ¬ í¬ì¸í„°**: ì •ë ¬ëœ ë°°ì—´ì—ì„œ ë‘ í¬ì¸í„°ë¥¼ ì´ìš©í•œ íš¨ìœ¨ì  íƒìƒ‰
- **í•´ì‹œ**: O(1) í‰ê·  ì‹œê°„ìœ¼ë¡œ ë¹ ë¥¸ ê²€ìƒ‰

---

## ğŸ”§ **ê¸°ë³¸ í…œí”Œë¦¿**

### **ì´ë¶„ íƒìƒ‰ (Binary Search)**
```cpp
#include <algorithm>

// ê¸°ë³¸ ì´ë¶„ íƒìƒ‰ - ê°’ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
bool binarySearch(vector<int>& arr, int target) {
    sort(arr.begin(), arr.end());
    
    int left = 0, right = arr.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;  // ì˜¤ë²„í”Œë¡œìš° ë°©ì§€
        
        if (arr[mid] == target) {
            return true;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return false;
}

// STL í™œìš©
bool exists = binary_search(arr.begin(), arr.end(), target);
int lowerIdx = lower_bound(arr.begin(), arr.end(), target) - arr.begin();
int upperIdx = upper_bound(arr.begin(), arr.end(), target) - arr.begin();
int count = upperIdx - lowerIdx;  // targetì˜ ê°œìˆ˜
```

### **íˆ¬ í¬ì¸í„° (Two Pointers)**
```cpp
// ë‘ ìˆ˜ì˜ í•©ì´ targetì¸ ìŒ ì°¾ê¸°
vector<pair<int, int>> twoSum(vector<int>& arr, int target) {
    sort(arr.begin(), arr.end());
    
    vector<pair<int, int>> result;
    int left = 0, right = arr.size() - 1;
    
    while (left < right) {
        int sum = arr[left] + arr[right];
        
        if (sum == target) {
            result.push_back({arr[left], arr[right]});
            left++;
            right--;
        } else if (sum < target) {
            left++;
        } else {
            right--;
        }
    }
    
    return result;
}

// ë¶€ë¶„í•©ì´ target ì´ìƒì¸ ìµœë‹¨ êµ¬ê°„
int shortestSubarray(vector<int>& arr, int target) {
    int left = 0, sum = 0;
    int minLength = INT_MAX;
    
    for (int right = 0; right < arr.size(); right++) {
        sum += arr[right];
        
        while (sum >= target) {
            minLength = min(minLength, right - left + 1);
            sum -= arr[left++];
        }
    }
    
    return minLength == INT_MAX ? 0 : minLength;
}
```

### **í•´ì‹œë§µ í™œìš©**
```cpp
#include <unordered_map>
#include <map>

// ë¹ˆë„ ì¹´ìš´íŒ…
unordered_map<int, int> countFrequency(const vector<int>& arr) {
    unordered_map<int, int> freq;
    for (int x : arr) {
        freq[x]++;
    }
    return freq;
}

// ë‘ ìˆ˜ì˜ í•© (í•´ì‹œë§µ ë²„ì „)
vector<int> twoSumHash(vector<int>& nums, int target) {
    unordered_map<int, int> map;
    
    for (int i = 0; i < nums.size(); i++) {
        int complement = target - nums[i];
        if (map.find(complement) != map.end()) {
            return {map[complement], i};
        }
        map[nums[i]] = i;
    }
    
    return {};
}
```

---

## ğŸ’¡ **í’€ì´ íŒ¨í„´**

### **1. ì´ë¶„ íƒìƒ‰ ì‘ìš©**
```cpp
// ë§¤ê°œë³€ìˆ˜ íƒìƒ‰ - ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ìµœì†Ÿê°’/ìµœëŒ“ê°’ ì°¾ê¸°
bool isPossible(int mid, const vector<int>& arr, int condition) {
    // midê°€ ë‹µì´ ë  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” í•¨ìˆ˜
    // êµ¬ì²´ì ì¸ êµ¬í˜„ì€ ë¬¸ì œì— ë”°ë¼ ë‹¬ë¼ì§
    return true;  // ì˜ˆì‹œ
}

int parametricSearch(const vector<int>& arr, int left, int right) {
    int answer = -1;
    
    while (left <= right) {
        int mid = (left + right) / 2;
        
        if (isPossible(mid, arr, 0)) {
            answer = mid;
            right = mid - 1;  // ë” ì‘ì€ ê°’ë„ ê°€ëŠ¥í•œì§€ í™•ì¸
        } else {
            left = mid + 1;   // ë” í° ê°’ í•„ìš”
        }
    }
    
    return answer;
}
```

### **2. ì¢Œí‘œ ì••ì¶•**
```cpp
// í° ì¢Œí‘œê°’ë“¤ì„ ì‘ì€ ë²”ìœ„ë¡œ ì••ì¶•
vector<int> coordinateCompression(vector<int>& coords) {
    vector<int> sorted_coords = coords;
    sort(sorted_coords.begin(), sorted_coords.end());
    sorted_coords.erase(unique(sorted_coords.begin(), sorted_coords.end()), 
                       sorted_coords.end());
    
    // ì›ë³¸ ì¢Œí‘œë“¤ì„ ì••ì¶•ëœ ì¸ë±ìŠ¤ë¡œ ë³€í™˜
    for (int& coord : coords) {
        coord = lower_bound(sorted_coords.begin(), sorted_coords.end(), coord) 
                - sorted_coords.begin();
    }
    
    return coords;
}
```

### **3. ì •ë ¬ ê¸°ì¤€ ì»¤ìŠ¤í„°ë§ˆì´ì§•**
```cpp
struct Student {
    string name;
    int age;
    int score;
};

// ì»¤ìŠ¤í…€ ë¹„êµ í•¨ìˆ˜
bool compareStudents(const Student& a, const Student& b) {
    if (a.score != b.score) return a.score > b.score;  // ì ìˆ˜ ë†’ì€ ìˆœ
    if (a.age != b.age) return a.age < b.age;          // ë‚˜ì´ ë‚®ì€ ìˆœ
    return a.name < b.name;                            // ì´ë¦„ ì‚¬ì „ìˆœ
}

// ëŒë‹¤ í•¨ìˆ˜ ì‚¬ìš©
sort(students.begin(), students.end(), [](const Student& a, const Student& b) {
    return a.score > b.score;
});

// ì—¬ëŸ¬ ì¡°ê±´ ì •ë ¬
sort(students.begin(), students.end(), [](const Student& a, const Student& b) {
    return make_tuple(-a.score, a.age, a.name) < 
           make_tuple(-b.score, b.age, b.name);
});
```

---

## ğŸ” **ì‹¤ì œ ì˜ˆì‹œ**

### **ì˜ˆì‹œ 1: ìˆ«ì ì¹´ë“œ 2 (10816ë²ˆ)**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, m;
    cin >> n;
    
    vector<int> cards(n);
    for (int i = 0; i < n; i++) {
        cin >> cards[i];
    }
    
    sort(cards.begin(), cards.end());
    
    cin >> m;
    for (int i = 0; i < m; i++) {
        int target;
        cin >> target;
        
        int count = upper_bound(cards.begin(), cards.end(), target) - 
                   lower_bound(cards.begin(), cards.end(), target);
        
        cout << count << " ";
    }
    
    return 0;
}
```

### **ì˜ˆì‹œ 2: ë‘ ìš©ì•¡ (2470ë²ˆ)**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    cin >> n;
    
    vector<int> solutions(n);
    for (int i = 0; i < n; i++) {
        cin >> solutions[i];
    }
    
    sort(solutions.begin(), solutions.end());
    
    int left = 0, right = n - 1;
    int bestSum = solutions[left] + solutions[right];
    int ansLeft = left, ansRight = right;
    
    while (left < right) {
        int sum = solutions[left] + solutions[right];
        
        if (abs(sum) < abs(bestSum)) {
            bestSum = sum;
            ansLeft = left;
            ansRight = right;
        }
        
        if (sum < 0) {
            left++;
        } else {
            right--;
        }
    }
    
    cout << solutions[ansLeft] << " " << solutions[ansRight] << "\n";
    
    return 0;
}
```

### **ì˜ˆì‹œ 3: ë‚˜ì´ìˆœ ì •ë ¬ (10814ë²ˆ)**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>

struct Member {
    int age;
    string name;
    int order;  // ì…ë ¥ ìˆœì„œ
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    cin >> n;
    
    vector<Member> members(n);
    for (int i = 0; i < n; i++) {
        cin >> members[i].age >> members[i].name;
        members[i].order = i;
    }
    
    // ì•ˆì • ì •ë ¬ì„ ìœ„í•´ ë‚˜ì´ -> ì…ë ¥ ìˆœì„œ ìˆœìœ¼ë¡œ ì •ë ¬
    sort(members.begin(), members.end(), [](const Member& a, const Member& b) {
        if (a.age != b.age) return a.age < b.age;
        return a.order < b.order;  // ê°™ì€ ë‚˜ì´ë©´ ì…ë ¥ ìˆœì„œëŒ€ë¡œ
    });
    
    for (const Member& member : members) {
        cout << member.age << " " << member.name << "\n";
    }
    
    return 0;
}
```

---

## âš¡ **ìµœì í™” íŒ**

### **1. ì •ë ¬ ìµœì í™”**
```cpp
// ì´ë¯¸ ë¶€ë¶„ì ìœ¼ë¡œ ì •ë ¬ëœ ê²½ìš°
if (is_sorted(arr.begin(), arr.end())) {
    // ì´ë¯¸ ì •ë ¬ë¨, ì¶”ê°€ ì •ë ¬ ë¶ˆí•„ìš”
}

// ë¶€ë¶„ ì •ë ¬ - ìƒìœ„ kê°œë§Œ í•„ìš”í•œ ê²½ìš°
partial_sort(arr.begin(), arr.begin() + k, arr.end());

// nth_element - kë²ˆì§¸ ìš”ì†Œë§Œ ì˜¬ë°”ë¥¸ ìœ„ì¹˜ì—
nth_element(arr.begin(), arr.begin() + k, arr.end());
```

### **2. ì´ë¶„ íƒìƒ‰ ìµœì í™”**
```cpp
// ì˜¤ë²„í”Œë¡œìš° ë°©ì§€
int mid = left + (right - left) / 2;

// ì‹¤ìˆ˜í˜• ì´ë¶„ íƒìƒ‰
double binarySearchDouble(double left, double right, double target) {
    const double EPS = 1e-9;
    
    while (right - left > EPS) {
        double mid = (left + right) / 2.0;
        
        if (f(mid) < target) {
            left = mid;
        } else {
            right = mid;
        }
    }
    
    return (left + right) / 2.0;
}
```

### **3. í•´ì‹œ ìµœì í™”**
```cpp
// unordered_map vs map
unordered_map<int, int> hashMap;  // O(1) í‰ê· , O(n) ìµœì•…
map<int, int> treeMap;           // O(log n) ë³´ì¥

// ì¶©ëŒ ìµœì†Œí™”ë¥¼ ìœ„í•œ ì»¤ìŠ¤í…€ í•´ì‹œ
struct CustomHash {
    size_t operator()(const pair<int, int>& p) const {
        return hash<int>()(p.first) ^ (hash<int>()(p.second) << 1);
    }
};

unordered_map<pair<int, int>, int, CustomHash> customHashMap;
```

---

## ğŸ“ **ê´€ë ¨ ë¬¸ì œ**

### **ì´ë¶„ íƒìƒ‰**
- 1920: ìˆ˜ ì°¾ê¸°
- 10816: ìˆ«ì ì¹´ë“œ 2  
- 1654: ëœì„  ìë¥´ê¸°
- 2512: ì˜ˆì‚°

### **íˆ¬ í¬ì¸í„°**
- 2470: ë‘ ìš©ì•¡
- 2003: ìˆ˜ë“¤ì˜ í•© 2
- 1806: ë¶€ë¶„í•©
- 2473: ì„¸ ìš©ì•¡

### **ì •ë ¬**
- 10814: ë‚˜ì´ìˆœ ì •ë ¬
- 11650: ì¢Œí‘œ ì •ë ¬í•˜ê¸°
- 1181: ë‹¨ì–´ ì •ë ¬
- 11399: ATM

### **í•´ì‹œ**
- 1764: ë“£ë³´ì¡
- 17219: ë¹„ë°€ë²ˆí˜¸ ì°¾ê¸°
- 9375: íŒ¨ì…˜ì™• ì‹ í•´ë¹ˆ

---

**ğŸ”‘ í•µì‹¬ í¬ì¸íŠ¸**:
- **ì •ë ¬ëœ ë°ì´í„°**ì—ì„œëŠ” ì´ë¶„ íƒìƒ‰ìœ¼ë¡œ O(log n) ê²€ìƒ‰
- **íˆ¬ í¬ì¸í„°**ëŠ” O(n)ìœ¼ë¡œ ë‘ ê°œ ì¡°ê±´ ë§Œì¡±í•˜ëŠ” ìŒ ì°¾ê¸°
- **í•´ì‹œë§µ**ìœ¼ë¡œ O(1) ë¹ ë¥¸ ê²€ìƒ‰ (í‰ê· )
- **STL í•¨ìˆ˜ë“¤** ì ê·¹ í™œìš©í•˜ê¸°