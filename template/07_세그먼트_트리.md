# 🌲 세그먼트 트리 (Segment Tree)

> **난이도**: Gold ~ Platinum  
> **대표 문제**: 2042(구간 합 구하기), 11505(구간 곱 구하기), 2357(최솟값과 최댓값)

---

## 🎯 **핵심 개념**

세그먼트 트리는 **구간 쿼리와 점 업데이트**를 효율적으로 처리하는 트리 자료구조입니다:
- **구간 쿼리**: 배열의 특정 구간에 대한 합, 최솟값, 최댓값 등을 O(log n)에 계산
- **점 업데이트**: 특정 인덱스의 값을 O(log n)에 변경
- **완전 이진 트리**: 리프 노드가 원소, 내부 노드가 구간 정보

---

## 🔧 **기본 템플릿**

### **구간 합 세그먼트 트리**
```cpp
class SegmentTree {
private:
    vector<long long> tree;
    int n;
    
    void build(const vector<int>& arr, int node, int start, int end) {
        if (start == end) {
            tree[node] = arr[start];
        } else {
            int mid = (start + end) / 2;
            build(arr, 2*node, start, mid);
            build(arr, 2*node+1, mid+1, end);
            tree[node] = tree[2*node] + tree[2*node+1];
        }
    }
    
    void update(int node, int start, int end, int idx, long long val) {
        if (start == end) {
            tree[node] = val;
        } else {
            int mid = (start + end) / 2;
            if (idx <= mid) {
                update(2*node, start, mid, idx, val);
            } else {
                update(2*node+1, mid+1, end, idx, val);
            }
            tree[node] = tree[2*node] + tree[2*node+1];
        }
    }
    
    long long query(int node, int start, int end, int l, int r) {
        if (r < start || end < l) {
            return 0;  // 구간이 겹치지 않음
        }
        if (l <= start && end <= r) {
            return tree[node];  // 완전히 포함됨
        }
        
        int mid = (start + end) / 2;
        return query(2*node, start, mid, l, r) + 
               query(2*node+1, mid+1, end, l, r);
    }

public:
    SegmentTree(const vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n);  // 넉넉하게 4배
        build(arr, 1, 0, n-1);
    }
    
    void update(int idx, long long val) {
        update(1, 0, n-1, idx, val);
    }
    
    long long sum(int l, int r) {
        return query(1, 0, n-1, l, r);
    }
};
```

### **최솟값/최댓값 세그먼트 트리**
```cpp
class MinMaxSegmentTree {
private:
    vector<pair<int, int>> tree;  // {min, max}
    int n;
    const int INF = 1e9;
    
    void build(const vector<int>& arr, int node, int start, int end) {
        if (start == end) {
            tree[node] = {arr[start], arr[start]};
        } else {
            int mid = (start + end) / 2;
            build(arr, 2*node, start, mid);
            build(arr, 2*node+1, mid+1, end);
            
            int leftMin = tree[2*node].first;
            int leftMax = tree[2*node].second;
            int rightMin = tree[2*node+1].first;
            int rightMax = tree[2*node+1].second;
            
            tree[node] = {min(leftMin, rightMin), max(leftMax, rightMax)};
        }
    }
    
    pair<int, int> query(int node, int start, int end, int l, int r) {
        if (r < start || end < l) {
            return {INF, -INF};  // 범위 밖
        }
        if (l <= start && end <= r) {
            return tree[node];
        }
        
        int mid = (start + end) / 2;
        auto left = query(2*node, start, mid, l, r);
        auto right = query(2*node+1, mid+1, end, l, r);
        
        return {min(left.first, right.first), 
                max(left.second, right.second)};
    }

public:
    MinMaxSegmentTree(const vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n);
        build(arr, 1, 0, n-1);
    }
    
    pair<int, int> minMax(int l, int r) {
        return query(1, 0, n-1, l, r);
    }
    
    int getMin(int l, int r) {
        return query(1, 0, n-1, l, r).first;
    }
    
    int getMax(int l, int r) {
        return query(1, 0, n-1, l, r).second;
    }
};
```

### **곱 세그먼트 트리 (모듈러)**
```cpp
class ProductSegmentTree {
private:
    vector<long long> tree;
    int n;
    const int MOD = 1000000007;
    
    long long multiply(long long a, long long b) {
        return (a * b) % MOD;
    }
    
    void build(const vector<int>& arr, int node, int start, int end) {
        if (start == end) {
            tree[node] = arr[start] % MOD;
        } else {
            int mid = (start + end) / 2;
            build(arr, 2*node, start, mid);
            build(arr, 2*node+1, mid+1, end);
            tree[node] = multiply(tree[2*node], tree[2*node+1]);
        }
    }
    
    void update(int node, int start, int end, int idx, long long val) {
        if (start == end) {
            tree[node] = val % MOD;
        } else {
            int mid = (start + end) / 2;
            if (idx <= mid) {
                update(2*node, start, mid, idx, val);
            } else {
                update(2*node+1, mid+1, end, idx, val);
            }
            tree[node] = multiply(tree[2*node], tree[2*node+1]);
        }
    }
    
    long long query(int node, int start, int end, int l, int r) {
        if (r < start || end < l) return 1;  // 곱의 항등원
        if (l <= start && end <= r) return tree[node];
        
        int mid = (start + end) / 2;
        return multiply(query(2*node, start, mid, l, r),
                       query(2*node+1, mid+1, end, l, r));
    }

public:
    ProductSegmentTree(const vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n);
        build(arr, 1, 0, n-1);
    }
    
    void update(int idx, long long val) {
        update(1, 0, n-1, idx, val);
    }
    
    long long product(int l, int r) {
        return query(1, 0, n-1, l, r);
    }
};
```

---

## 💡 **고급 기법**

### **1. Lazy Propagation (구간 업데이트)**
```cpp
class LazySegmentTree {
private:
    vector<long long> tree, lazy;
    int n;
    
    void push(int node, int start, int end) {
        if (lazy[node] != 0) {
            tree[node] += lazy[node] * (end - start + 1);
            
            if (start != end) {  // 리프가 아니면
                lazy[2*node] += lazy[node];
                lazy[2*node+1] += lazy[node];
            }
            lazy[node] = 0;
        }
    }
    
    void updateRange(int node, int start, int end, int l, int r, long long val) {
        push(node, start, end);
        
        if (start > r || end < l) return;
        
        if (start >= l && end <= r) {
            lazy[node] += val;
            push(node, start, end);
            return;
        }
        
        int mid = (start + end) / 2;
        updateRange(2*node, start, mid, l, r, val);
        updateRange(2*node+1, mid+1, end, l, r, val);
        
        push(2*node, start, mid);
        push(2*node+1, mid+1, end);
        tree[node] = tree[2*node] + tree[2*node+1];
    }
    
    long long query(int node, int start, int end, int l, int r) {
        if (start > r || end < l) return 0;
        
        push(node, start, end);
        
        if (start >= l && end <= r) return tree[node];
        
        int mid = (start + end) / 2;
        return query(2*node, start, mid, l, r) + 
               query(2*node+1, mid+1, end, l, r);
    }

public:
    LazySegmentTree(int size) {
        n = size;
        tree.resize(4 * n, 0);
        lazy.resize(4 * n, 0);
    }
    
    void updateRange(int l, int r, long long val) {
        updateRange(1, 0, n-1, l, r, val);
    }
    
    long long sum(int l, int r) {
        return query(1, 0, n-1, l, r);
    }
};
```

---

## 🔍 **실제 예시**

### **예시 1: 구간 합 구하기 (2042번)**
```cpp
#include <iostream>
#include <vector>

class SegmentTree {
    // ... (위의 구간 합 세그먼트 트리 코드)
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, m, k;
    cin >> n >> m >> k;
    
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    
    SegmentTree st(arr);
    
    for (int i = 0; i < m + k; i++) {
        int a;
        cin >> a;
        
        if (a == 1) {  // 업데이트
            int b;
            long long c;
            cin >> b >> c;
            st.update(b - 1, c);  // 0-based 인덱스
        } else {  // 쿼리
            int b, c;
            cin >> b >> c;
            cout << st.sum(b - 1, c - 1) << "\n";  // 0-based 인덱스
        }
    }
    
    return 0;
}
```

### **예시 2: 최솟값과 최댓값 (2357번)**
```cpp
#include <iostream>
#include <vector>

class MinMaxSegmentTree {
    // ... (위의 최솟값/최댓값 세그먼트 트리 코드)
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, m;
    cin >> n >> m;
    
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    
    MinMaxSegmentTree st(arr);
    
    for (int i = 0; i < m; i++) {
        int a, b;
        cin >> a >> b;
        
        auto result = st.minMax(a - 1, b - 1);  // 0-based 인덱스
        cout << result.first << " " << result.second << "\n";
    }
    
    return 0;
}
```

---

## ⚡ **최적화 팁**

### **1. 메모리 최적화**
```cpp
// 동적 할당 대신 정확한 크기 계산
int treeSize = 1;
while (treeSize < n) treeSize <<= 1;
treeSize <<= 1;  // 2 * treeSize
vector<long long> tree(treeSize);
```

### **2. 재귀 최적화**
```cpp
// 반복문 버전 (더 빠름)
class IterativeSegmentTree {
private:
    vector<long long> tree;
    int n;
    
public:
    IterativeSegmentTree(const vector<int>& arr) {
        n = arr.size();
        tree.resize(2 * n);
        
        // 리프 노드에 값 복사
        for (int i = 0; i < n; i++) {
            tree[n + i] = arr[i];
        }
        
        // 내부 노드 계산
        for (int i = n - 1; i > 0; i--) {
            tree[i] = tree[2*i] + tree[2*i + 1];
        }
    }
    
    void update(int pos, long long val) {
        pos += n;  // 리프 노드 위치
        tree[pos] = val;
        
        while (pos > 1) {
            pos >>= 1;
            tree[pos] = tree[2*pos] + tree[2*pos + 1];
        }
    }
    
    long long sum(int l, int r) {
        long long result = 0;
        l += n; r += n;
        
        while (l <= r) {
            if (l % 2 == 1) result += tree[l++];
            if (r % 2 == 0) result += tree[r--];
            l >>= 1; r >>= 1;
        }
        
        return result;
    }
};
```

---

## 📊 **시간/공간 복잡도**

- **빌드**: O(n)
- **업데이트**: O(log n)
- **쿼리**: O(log n)  
- **공간**: O(4n) ≈ O(n)

Lazy Propagation 적용 시:
- **구간 업데이트**: O(log n)
- **추가 공간**: O(n) (lazy 배열)

---

## 📝 **관련 문제**

### **기초**
- 2042: 구간 합 구하기
- 2357: 최솟값과 최댓값
- 11505: 구간 곱 구하기

### **Lazy Propagation**
- 10999: 구간 합 구하기 2
- 12844: XOR

### **고급 응용**
- 1275: 커피숍2
- 12015: 가장 긴 증가하는 부분 수열 2
- 2243: 사탕상자

### **2D 세그먼트 트리**
- 11658: 구간 합 구하기 3

---

**🔑 핵심 포인트**:
- **트리 크기**: 배열 크기의 4배로 설정
- **인덱싱**: 1-based 인덱싱 사용 (루트가 1)
- **구간 표현**: [start, end] 닫힌 구간
- **Lazy Propagation**: 구간 업데이트 시 필수