# ğŸŒ² ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ (Segment Tree)

> **ë‚œì´ë„**: Gold ~ Platinum  
> **ëŒ€í‘œ ë¬¸ì œ**: 2042(êµ¬ê°„ í•© êµ¬í•˜ê¸°), 11505(êµ¬ê°„ ê³± êµ¬í•˜ê¸°), 2357(ìµœì†Ÿê°’ê³¼ ìµœëŒ“ê°’)

---

## ğŸ¯ **í•µì‹¬ ê°œë…**

ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ëŠ” **êµ¬ê°„ ì¿¼ë¦¬ì™€ ì  ì—…ë°ì´íŠ¸**ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ëŠ” íŠ¸ë¦¬ ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤:
- **êµ¬ê°„ ì¿¼ë¦¬**: ë°°ì—´ì˜ íŠ¹ì • êµ¬ê°„ì— ëŒ€í•œ í•©, ìµœì†Ÿê°’, ìµœëŒ“ê°’ ë“±ì„ O(log n)ì— ê³„ì‚°
- **ì  ì—…ë°ì´íŠ¸**: íŠ¹ì • ì¸ë±ìŠ¤ì˜ ê°’ì„ O(log n)ì— ë³€ê²½
- **ì™„ì „ ì´ì§„ íŠ¸ë¦¬**: ë¦¬í”„ ë…¸ë“œê°€ ì›ì†Œ, ë‚´ë¶€ ë…¸ë“œê°€ êµ¬ê°„ ì •ë³´

---

## ğŸ”§ **ê¸°ë³¸ í…œí”Œë¦¿**

### **êµ¬ê°„ í•© ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬**
```cpp
class SegmentTree {
private:
    vector<long long> tree;
    int n;
    
    void build(const vector<int>& arr, int node, int start, int end) {
        if (start == end) {
            tree[node] = arr[start];
        } else {
            int mid = (start + end) / 2;
            build(arr, 2*node, start, mid);
            build(arr, 2*node+1, mid+1, end);
            tree[node] = tree[2*node] + tree[2*node+1];
        }
    }
    
    void update(int node, int start, int end, int idx, long long val) {
        if (start == end) {
            tree[node] = val;
        } else {
            int mid = (start + end) / 2;
            if (idx <= mid) {
                update(2*node, start, mid, idx, val);
            } else {
                update(2*node+1, mid+1, end, idx, val);
            }
            tree[node] = tree[2*node] + tree[2*node+1];
        }
    }
    
    long long query(int node, int start, int end, int l, int r) {
        if (r < start || end < l) {
            return 0;  // êµ¬ê°„ì´ ê²¹ì¹˜ì§€ ì•ŠìŒ
        }
        if (l <= start && end <= r) {
            return tree[node];  // ì™„ì „íˆ í¬í•¨ë¨
        }
        
        int mid = (start + end) / 2;
        return query(2*node, start, mid, l, r) + 
               query(2*node+1, mid+1, end, l, r);
    }

public:
    SegmentTree(const vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n);  // ë„‰ë„‰í•˜ê²Œ 4ë°°
        build(arr, 1, 0, n-1);
    }
    
    void update(int idx, long long val) {
        update(1, 0, n-1, idx, val);
    }
    
    long long sum(int l, int r) {
        return query(1, 0, n-1, l, r);
    }
};
```

### **ìµœì†Ÿê°’/ìµœëŒ“ê°’ ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬**
```cpp
class MinMaxSegmentTree {
private:
    vector<pair<int, int>> tree;  // {min, max}
    int n;
    const int INF = 1e9;
    
    void build(const vector<int>& arr, int node, int start, int end) {
        if (start == end) {
            tree[node] = {arr[start], arr[start]};
        } else {
            int mid = (start + end) / 2;
            build(arr, 2*node, start, mid);
            build(arr, 2*node+1, mid+1, end);
            
            int leftMin = tree[2*node].first;
            int leftMax = tree[2*node].second;
            int rightMin = tree[2*node+1].first;
            int rightMax = tree[2*node+1].second;
            
            tree[node] = {min(leftMin, rightMin), max(leftMax, rightMax)};
        }
    }
    
    pair<int, int> query(int node, int start, int end, int l, int r) {
        if (r < start || end < l) {
            return {INF, -INF};  // ë²”ìœ„ ë°–
        }
        if (l <= start && end <= r) {
            return tree[node];
        }
        
        int mid = (start + end) / 2;
        auto left = query(2*node, start, mid, l, r);
        auto right = query(2*node+1, mid+1, end, l, r);
        
        return {min(left.first, right.first), 
                max(left.second, right.second)};
    }

public:
    MinMaxSegmentTree(const vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n);
        build(arr, 1, 0, n-1);
    }
    
    pair<int, int> minMax(int l, int r) {
        return query(1, 0, n-1, l, r);
    }
    
    int getMin(int l, int r) {
        return query(1, 0, n-1, l, r).first;
    }
    
    int getMax(int l, int r) {
        return query(1, 0, n-1, l, r).second;
    }
};
```

### **ê³± ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ (ëª¨ë“ˆëŸ¬)**
```cpp
class ProductSegmentTree {
private:
    vector<long long> tree;
    int n;
    const int MOD = 1000000007;
    
    long long multiply(long long a, long long b) {
        return (a * b) % MOD;
    }
    
    void build(const vector<int>& arr, int node, int start, int end) {
        if (start == end) {
            tree[node] = arr[start] % MOD;
        } else {
            int mid = (start + end) / 2;
            build(arr, 2*node, start, mid);
            build(arr, 2*node+1, mid+1, end);
            tree[node] = multiply(tree[2*node], tree[2*node+1]);
        }
    }
    
    void update(int node, int start, int end, int idx, long long val) {
        if (start == end) {
            tree[node] = val % MOD;
        } else {
            int mid = (start + end) / 2;
            if (idx <= mid) {
                update(2*node, start, mid, idx, val);
            } else {
                update(2*node+1, mid+1, end, idx, val);
            }
            tree[node] = multiply(tree[2*node], tree[2*node+1]);
        }
    }
    
    long long query(int node, int start, int end, int l, int r) {
        if (r < start || end < l) return 1;  // ê³±ì˜ í•­ë“±ì›
        if (l <= start && end <= r) return tree[node];
        
        int mid = (start + end) / 2;
        return multiply(query(2*node, start, mid, l, r),
                       query(2*node+1, mid+1, end, l, r));
    }

public:
    ProductSegmentTree(const vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n);
        build(arr, 1, 0, n-1);
    }
    
    void update(int idx, long long val) {
        update(1, 0, n-1, idx, val);
    }
    
    long long product(int l, int r) {
        return query(1, 0, n-1, l, r);
    }
};
```

---

## ğŸ’¡ **ê³ ê¸‰ ê¸°ë²•**

### **1. Lazy Propagation (êµ¬ê°„ ì—…ë°ì´íŠ¸)**
```cpp
class LazySegmentTree {
private:
    vector<long long> tree, lazy;
    int n;
    
    void push(int node, int start, int end) {
        if (lazy[node] != 0) {
            tree[node] += lazy[node] * (end - start + 1);
            
            if (start != end) {  // ë¦¬í”„ê°€ ì•„ë‹ˆë©´
                lazy[2*node] += lazy[node];
                lazy[2*node+1] += lazy[node];
            }
            lazy[node] = 0;
        }
    }
    
    void updateRange(int node, int start, int end, int l, int r, long long val) {
        push(node, start, end);
        
        if (start > r || end < l) return;
        
        if (start >= l && end <= r) {
            lazy[node] += val;
            push(node, start, end);
            return;
        }
        
        int mid = (start + end) / 2;
        updateRange(2*node, start, mid, l, r, val);
        updateRange(2*node+1, mid+1, end, l, r, val);
        
        push(2*node, start, mid);
        push(2*node+1, mid+1, end);
        tree[node] = tree[2*node] + tree[2*node+1];
    }
    
    long long query(int node, int start, int end, int l, int r) {
        if (start > r || end < l) return 0;
        
        push(node, start, end);
        
        if (start >= l && end <= r) return tree[node];
        
        int mid = (start + end) / 2;
        return query(2*node, start, mid, l, r) + 
               query(2*node+1, mid+1, end, l, r);
    }

public:
    LazySegmentTree(int size) {
        n = size;
        tree.resize(4 * n, 0);
        lazy.resize(4 * n, 0);
    }
    
    void updateRange(int l, int r, long long val) {
        updateRange(1, 0, n-1, l, r, val);
    }
    
    long long sum(int l, int r) {
        return query(1, 0, n-1, l, r);
    }
};
```

---

## ğŸ” **ì‹¤ì œ ì˜ˆì‹œ**

### **ì˜ˆì‹œ 1: êµ¬ê°„ í•© êµ¬í•˜ê¸° (2042ë²ˆ)**
```cpp
#include <iostream>
#include <vector>

class SegmentTree {
    // ... (ìœ„ì˜ êµ¬ê°„ í•© ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ ì½”ë“œ)
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, m, k;
    cin >> n >> m >> k;
    
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    
    SegmentTree st(arr);
    
    for (int i = 0; i < m + k; i++) {
        int a;
        cin >> a;
        
        if (a == 1) {  // ì—…ë°ì´íŠ¸
            int b;
            long long c;
            cin >> b >> c;
            st.update(b - 1, c);  // 0-based ì¸ë±ìŠ¤
        } else {  // ì¿¼ë¦¬
            int b, c;
            cin >> b >> c;
            cout << st.sum(b - 1, c - 1) << "\n";  // 0-based ì¸ë±ìŠ¤
        }
    }
    
    return 0;
}
```

### **ì˜ˆì‹œ 2: ìµœì†Ÿê°’ê³¼ ìµœëŒ“ê°’ (2357ë²ˆ)**
```cpp
#include <iostream>
#include <vector>

class MinMaxSegmentTree {
    // ... (ìœ„ì˜ ìµœì†Ÿê°’/ìµœëŒ“ê°’ ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ ì½”ë“œ)
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, m;
    cin >> n >> m;
    
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    
    MinMaxSegmentTree st(arr);
    
    for (int i = 0; i < m; i++) {
        int a, b;
        cin >> a >> b;
        
        auto result = st.minMax(a - 1, b - 1);  // 0-based ì¸ë±ìŠ¤
        cout << result.first << " " << result.second << "\n";
    }
    
    return 0;
}
```

---

## âš¡ **ìµœì í™” íŒ**

### **1. ë©”ëª¨ë¦¬ ìµœì í™”**
```cpp
// ë™ì  í• ë‹¹ ëŒ€ì‹  ì •í™•í•œ í¬ê¸° ê³„ì‚°
int treeSize = 1;
while (treeSize < n) treeSize <<= 1;
treeSize <<= 1;  // 2 * treeSize
vector<long long> tree(treeSize);
```

### **2. ì¬ê·€ ìµœì í™”**
```cpp
// ë°˜ë³µë¬¸ ë²„ì „ (ë” ë¹ ë¦„)
class IterativeSegmentTree {
private:
    vector<long long> tree;
    int n;
    
public:
    IterativeSegmentTree(const vector<int>& arr) {
        n = arr.size();
        tree.resize(2 * n);
        
        // ë¦¬í”„ ë…¸ë“œì— ê°’ ë³µì‚¬
        for (int i = 0; i < n; i++) {
            tree[n + i] = arr[i];
        }
        
        // ë‚´ë¶€ ë…¸ë“œ ê³„ì‚°
        for (int i = n - 1; i > 0; i--) {
            tree[i] = tree[2*i] + tree[2*i + 1];
        }
    }
    
    void update(int pos, long long val) {
        pos += n;  // ë¦¬í”„ ë…¸ë“œ ìœ„ì¹˜
        tree[pos] = val;
        
        while (pos > 1) {
            pos >>= 1;
            tree[pos] = tree[2*pos] + tree[2*pos + 1];
        }
    }
    
    long long sum(int l, int r) {
        long long result = 0;
        l += n; r += n;
        
        while (l <= r) {
            if (l % 2 == 1) result += tree[l++];
            if (r % 2 == 0) result += tree[r--];
            l >>= 1; r >>= 1;
        }
        
        return result;
    }
};
```

---

## ğŸ“Š **ì‹œê°„/ê³µê°„ ë³µì¡ë„**

- **ë¹Œë“œ**: O(n)
- **ì—…ë°ì´íŠ¸**: O(log n)
- **ì¿¼ë¦¬**: O(log n)  
- **ê³µê°„**: O(4n) â‰ˆ O(n)

Lazy Propagation ì ìš© ì‹œ:
- **êµ¬ê°„ ì—…ë°ì´íŠ¸**: O(log n)
- **ì¶”ê°€ ê³µê°„**: O(n) (lazy ë°°ì—´)

---

## ğŸ“ **ê´€ë ¨ ë¬¸ì œ**

### **ê¸°ì´ˆ**
- 2042: êµ¬ê°„ í•© êµ¬í•˜ê¸°
- 2357: ìµœì†Ÿê°’ê³¼ ìµœëŒ“ê°’
- 11505: êµ¬ê°„ ê³± êµ¬í•˜ê¸°

### **Lazy Propagation**
- 10999: êµ¬ê°„ í•© êµ¬í•˜ê¸° 2
- 12844: XOR

### **ê³ ê¸‰ ì‘ìš©**
- 1275: ì»¤í”¼ìˆ2
- 12015: ê°€ì¥ ê¸´ ì¦ê°€í•˜ëŠ” ë¶€ë¶„ ìˆ˜ì—´ 2
- 2243: ì‚¬íƒ•ìƒì

### **2D ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬**
- 11658: êµ¬ê°„ í•© êµ¬í•˜ê¸° 3

---

**ğŸ”‘ í•µì‹¬ í¬ì¸íŠ¸**:
- **íŠ¸ë¦¬ í¬ê¸°**: ë°°ì—´ í¬ê¸°ì˜ 4ë°°ë¡œ ì„¤ì •
- **ì¸ë±ì‹±**: 1-based ì¸ë±ì‹± ì‚¬ìš© (ë£¨íŠ¸ê°€ 1)
- **êµ¬ê°„ í‘œí˜„**: [start, end] ë‹«íŒ êµ¬ê°„
- **Lazy Propagation**: êµ¬ê°„ ì—…ë°ì´íŠ¸ ì‹œ í•„ìˆ˜