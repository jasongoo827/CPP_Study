# 💰 기초 동적계획법 (DP)

> **난이도**: Silver ~ Gold  
> **대표 문제**: 1463(1로 만들기), 11726(2×n 타일링), 1932(정수 삼각형)

---

## 🎯 **핵심 개념**

동적계획법(Dynamic Programming)은 **복잡한 문제를 작은 문제들로 분해**하여 효율적으로 해결하는 기법입니다:
- **최적 부분구조**: 큰 문제의 최적해가 작은 문제의 최적해로 구성됨
- **중복 부분문제**: 같은 부분문제가 여러 번 등장함
- **메모이제이션**: 계산한 결과를 저장하여 중복 계산 방지

---

## 🔧 **기본 템플릿**

### **Bottom-Up 방식**
```cpp
// 1차원 DP - 기본 템플릿
vector<int> dp(n + 1);
dp[0] = baseCase0;  // 기저 사례
dp[1] = baseCase1;

for (int i = 2; i <= n; i++) {
    dp[i] = recurrence(dp[i-1], dp[i-2], ...);  // 점화식
}

return dp[n];

// 2차원 DP - 기본 템플릿  
vector<vector<int>> dp(n + 1, vector<int>(m + 1));

// 기저 조건 설정
for (int i = 0; i <= n; i++) dp[i][0] = baseCase;
for (int j = 0; j <= m; j++) dp[0][j] = baseCase;

for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        dp[i][j] = recurrence(dp[i-1][j], dp[i][j-1], ...);
    }
}

return dp[n][m];
```

### **Top-Down 방식 (메모이제이션)**
```cpp
vector<int> memo;

int solve(int n) {
    // 기저 사례
    if (n == 0) return baseCase0;
    if (n == 1) return baseCase1;
    
    // 이미 계산된 경우
    if (memo[n] != -1) return memo[n];
    
    // 점화식 계산 후 저장
    memo[n] = recurrence(solve(n-1), solve(n-2), ...);
    return memo[n];
}

// 사용법
memo.assign(n + 1, -1);
int result = solve(n);
```

---

## 💡 **기본 DP 패턴**

### **1. 최솟값/최댓값 DP**
```cpp
// dp[i] = i에 도달하는 최소/최대 비용
int minCost(vector<int>& cost) {
    int n = cost.size();
    vector<int> dp(n + 1, INT_MAX);
    
    dp[0] = 0;  // 시작점
    
    for (int i = 0; i < n; i++) {
        if (dp[i] == INT_MAX) continue;
        
        // 가능한 다음 상태들
        dp[i + 1] = min(dp[i + 1], dp[i] + cost[i]);
        if (i + 2 <= n) {
            dp[i + 2] = min(dp[i + 2], dp[i] + cost[i]);
        }
    }
    
    return dp[n];
}
```

### **2. 경우의 수 DP**
```cpp
// dp[i] = i를 만드는 방법의 수
int countWays(int n) {
    vector<long long> dp(n + 1, 0);
    
    dp[0] = 1;  // 아무것도 안 하는 경우 = 1가지
    
    for (int i = 1; i <= n; i++) {
        // 가능한 이전 상태들의 합
        if (i >= 1) dp[i] += dp[i - 1];
        if (i >= 2) dp[i] += dp[i - 2];
        
        dp[i] %= MOD;  // 모듈러 연산
    }
    
    return dp[n];
}
```

### **3. 가능성 DP (boolean)**
```cpp
// dp[i] = i를 만들 수 있는가?
bool isPossible(int target, vector<int>& nums) {
    vector<bool> dp(target + 1, false);
    dp[0] = true;  // 0은 항상 가능
    
    for (int i = 0; i <= target; i++) {
        if (!dp[i]) continue;
        
        for (int num : nums) {
            if (i + num <= target) {
                dp[i + num] = true;
            }
        }
    }
    
    return dp[target];
}
```

---

## 🔍 **실제 예시**

### **예시 1: 1로 만들기 (1463번)**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    cin >> n;
    
    vector<int> dp(n + 1, INT_MAX);
    dp[1] = 0;
    
    for (int i = 1; i < n; i++) {
        if (dp[i] == INT_MAX) continue;
        
        // -1 연산
        if (i + 1 <= n) {
            dp[i + 1] = min(dp[i + 1], dp[i] + 1);
        }
        
        // *2 연산 (역산: /2)
        if (i * 2 <= n) {
            dp[i * 2] = min(dp[i * 2], dp[i] + 1);
        }
        
        // *3 연산 (역산: /3)
        if (i * 3 <= n) {
            dp[i * 3] = min(dp[i * 3], dp[i] + 1);
        }
    }
    
    cout << dp[n] << "\n";
    
    return 0;
}

// 더 직관적인 버전
int main() {
    int n;
    cin >> n;
    
    vector<int> dp(n + 1, INT_MAX);
    dp[1] = 0;
    
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + 1;  // -1 연산
        
        if (i % 2 == 0) {
            dp[i] = min(dp[i], dp[i / 2] + 1);  // /2 연산
        }
        
        if (i % 3 == 0) {
            dp[i] = min(dp[i], dp[i / 3] + 1);  // /3 연산
        }
    }
    
    cout << dp[n] << "\n";
    return 0;
}
```

### **예시 2: 2×n 타일링 (11726번)**
```cpp
#include <iostream>
#include <vector>

const int MOD = 10007;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    cin >> n;
    
    if (n == 1) {
        cout << 1 << "\n";
        return 0;
    }
    
    vector<int> dp(n + 1);
    dp[1] = 1;  // 2×1을 채우는 방법: 세로 타일 1개
    dp[2] = 2;  // 2×2를 채우는 방법: 세로 2개 or 가로 2개
    
    for (int i = 3; i <= n; i++) {
        // 마지막에 세로 타일 1개 추가 or 가로 타일 2개 추가
        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD;
    }
    
    cout << dp[n] << "\n";
    
    return 0;
}
```

### **예시 3: 정수 삼각형 (1932번)**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    cin >> n;
    
    vector<vector<int>> triangle(n);
    vector<vector<int>> dp(n);
    
    for (int i = 0; i < n; i++) {
        triangle[i].resize(i + 1);
        dp[i].resize(i + 1);
        
        for (int j = 0; j <= i; j++) {
            cin >> triangle[i][j];
        }
    }
    
    // 첫 번째 줄 초기화
    dp[0][0] = triangle[0][0];
    
    // 아래로 내려가면서 최댓값 계산
    for (int i = 1; i < n; i++) {
        for (int j = 0; j <= i; j++) {
            dp[i][j] = triangle[i][j];
            
            int maxPrev = INT_MIN;
            
            // 왼쪽 위에서 오는 경우
            if (j - 1 >= 0) {
                maxPrev = max(maxPrev, dp[i - 1][j - 1]);
            }
            
            // 바로 위에서 오는 경우
            if (j < i) {
                maxPrev = max(maxPrev, dp[i - 1][j]);
            }
            
            if (maxPrev != INT_MIN) {
                dp[i][j] += maxPrev;
            }
        }
    }
    
    // 마지막 줄에서 최댓값 찾기
    int answer = *max_element(dp[n - 1].begin(), dp[n - 1].end());
    cout << answer << "\n";
    
    return 0;
}
```

---

## ⚡ **최적화 기법**

### **1. 공간 복잡도 최적화**
```cpp
// 2차원 DP를 1차원으로 최적화 (이전 행만 필요한 경우)
vector<int> prev(m + 1), curr(m + 1);

for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        curr[j] = recurrence(prev[j], curr[j-1], ...);
    }
    prev = curr;  // 현재 행을 이전 행으로
}

// 더 나아가서 in-place 최적화
vector<int> dp(m + 1);
for (int i = 1; i <= n; i++) {
    for (int j = m; j >= 1; j--) {  // 역순으로 갱신
        dp[j] = recurrence(dp[j], dp[j-1], ...);
    }
}
```

### **2. 롤링 배열**
```cpp
// 최근 k개 상태만 유지
vector<vector<int>> dp(k, vector<int>(m + 1));
int curr = 0;

for (int i = 1; i <= n; i++) {
    int next = (curr + 1) % k;
    
    for (int j = 1; j <= m; j++) {
        dp[next][j] = recurrence(dp[curr][j], dp[next][j-1], ...);
    }
    
    curr = next;
}
```

### **3. 상태 압축**
```cpp
// 비트마스킹을 이용한 상태 압축
vector<vector<int>> dp(n + 1, vector<int>(1 << m, -1));

int solve(int pos, int mask) {
    if (pos == n) return (mask == 0) ? 1 : 0;
    
    if (dp[pos][mask] != -1) return dp[pos][mask];
    
    // 다음 상태로 전이
    return dp[pos][mask] = transition(pos + 1, nextMask);
}
```

---

## 📝 **주요 DP 유형**

### **선형 DP**
- 1463: 1로 만들기
- 2579: 계단 오르기
- 11726: 2×n 타일링

### **2차원 DP**  
- 1932: 정수 삼각형
- 11053: 가장 긴 증가하는 부분 수열
- 9251: LCS

### **배낭 DP**
- 12865: 평범한 배낭
- 11052: 카드 구매하기

### **구간 DP**
- 11049: 행렬 곱셈 순서
- 2293: 동전 1

---

**🔑 핵심 포인트**:
- **점화식** 도출이 가장 중요
- **기저 조건** 정확히 설정
- **상태 정의** 명확하게
- **메모리/시간** 최적화 고려