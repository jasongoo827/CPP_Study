# 🔤 구현과 문자열 처리

> **난이도**: Bronze ~ Silver  
> **대표 문제**: 2941(크로아티아 알파벳), 1152(단어의 개수), 2798(블랙잭)

---

## 🎯 **핵심 개념**

구현과 문자열 처리는 프로그래밍의 기초입니다:
- **구현**: 문제에서 요구하는 동작을 정확히 코드로 표현
- **문자열 처리**: 텍스트 데이터를 파싱, 변환, 분석
- **시뮬레이션**: 주어진 규칙에 따라 상황을 단계별로 재현

---

## 🔧 **기본 템플릿**

### **문자열 기본 조작**
```cpp
#include <string>
#include <sstream>
#include <algorithm>

// 문자열 치환
string replace(string str, string from, string to) {
    size_t pos = 0;
    while ((pos = str.find(from, pos)) != string::npos) {
        str.replace(pos, from.length(), to);
        pos += to.length();
    }
    return str;
}

// 공백 기준 단어 분할
vector<string> split(const string& str) {
    istringstream iss(str);
    vector<string> words;
    string word;
    
    while (iss >> word) {
        words.push_back(word);
    }
    return words;
}

// 특정 문자 개수 세기
int countChar(const string& str, char c) {
    return count(str.begin(), str.end(), c);
}
```

### **브루트 포스 (완전탐색)**
```cpp
// 3중 루프 완전탐색 (블랙잭)
int bruteForce3(vector<int>& arr, int target) {
    int n = arr.size();
    int maxSum = 0;
    
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            for (int k = j + 1; k < n; k++) {
                int sum = arr[i] + arr[j] + arr[k];
                if (sum <= target) {
                    maxSum = max(maxSum, sum);
                }
            }
        }
    }
    return maxSum;
}

// 순열 생성 (next_permutation 활용)
vector<int> arr = {1, 2, 3};
do {
    // 현재 순열 처리
    for (int x : arr) cout << x << " ";
    cout << "\n";
} while (next_permutation(arr.begin(), arr.end()));
```

---

## 💡 **풀이 패턴**

### **1. 문자열 변환 문제**
```cpp
// 크로아티아 알파벳 처리 (2941번)
string croatian[] = {"c=", "c-", "dz=", "d-", "lj", "nj", "s=", "z="};

int countCroatian(string str) {
    for (const string& pattern : croatian) {
        str = replace(str, pattern, "*");  // 한 글자로 치환
    }
    return str.length();
}
```

### **2. 숫자 처리 문제**
```cpp
// 자릿수 계산
int digitCount(int n) {
    if (n == 0) return 1;
    int count = 0;
    while (n > 0) {
        count++;
        n /= 10;
    }
    return count;
}

// 각 자릿수 분해
vector<int> getDigits(int n) {
    vector<int> digits;
    if (n == 0) digits.push_back(0);
    
    while (n > 0) {
        digits.push_back(n % 10);
        n /= 10;
    }
    reverse(digits.begin(), digits.end());  // 올바른 순서로
    return digits;
}
```

### **3. 수학 공식 활용**
```cpp
// 달팽이 문제 (2869번)
// 하루에 (A-B)씩 올라가고, 마지막 날에는 A만큼
int snailDays(int A, int B, int V) {
    return (V - B - 1) / (A - B) + 1;
}

// 손익분기점 (1712번)
int breakEven(int A, int B, int C) {
    if (B >= C) return -1;  // 손익분기점 없음
    return A / (C - B) + 1;
}
```

---

## 🔍 **실제 예시**

### **예시 1: 단어의 개수 (1152번)**
```cpp
#include <iostream>
#include <string>
#include <sstream>

int main() {
    string line;
    getline(cin, line);
    
    istringstream iss(line);
    string word;
    int count = 0;
    
    while (iss >> word) {
        count++;
    }
    
    cout << count << "\n";
    return 0;
}
```

### **예시 2: 블랙잭 (2798번)**  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    int n, m;
    cin >> n >> m;
    
    vector<int> cards(n);
    for (int i = 0; i < n; i++) {
        cin >> cards[i];
    }
    
    int maxSum = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            for (int k = j + 1; k < n; k++) {
                int sum = cards[i] + cards[j] + cards[k];
                if (sum <= m) {
                    maxSum = max(maxSum, sum);
                }
            }
        }
    }
    
    cout << maxSum << "\n";
    return 0;
}
```

---

## ⚡ **최적화 팁**

### **1. 문자열 처리 최적화**
```cpp
// reserve로 메모리 미리 할당
string result;
result.reserve(1000);

// += 연산보다 append가 더 효율적일 수 있음
result.append(str);

// find 함수의 시작 위치 지정으로 중복 탐색 방지
size_t pos = 0;
while ((pos = str.find(pattern, pos)) != string::npos) {
    // 처리
    pos += pattern.length();
}
```

### **2. 입출력 최적화**
```cpp
// 빠른 입출력
ios::sync_with_stdio(false);
cin.tie(nullptr);

// 줄 단위 입력
string line;
while (getline(cin, line)) {
    // 처리
}
```

### **3. 완전탐색 최적화**
```cpp
// 조기 종료 (early termination)
for (int i = 0; i < n && !found; i++) {
    for (int j = i + 1; j < n; j++) {
        if (condition) {
            found = true;
            break;
        }
    }
}

// 중복 제거
sort(arr.begin(), arr.end());
arr.erase(unique(arr.begin(), arr.end()), arr.end());
```

---

## 📝 **관련 문제**

### **기초**
- 2557: Hello World
- 10171: 고양이  
- 2588: 곱셈

### **문자열**
- 1152: 단어의 개수
- 2675: 문자열 반복
- 2941: 크로아티아 알파벳
- 1259: 팰린드롬수

### **구현**  
- 2798: 블랙잭
- 2231: 분해합
- 1018: 체스판 다시 칠하기
- 1436: 영화감독 숌

### **수학**
- 2869: 달팽이는 올라가고 싶다
- 1712: 손익분기점  
- 2839: 설탕 배달

---

**🔑 핵심 포인트**: 
- **정확한 구현**이 가장 중요
- **예외 상황** 꼼꼼히 처리
- **효율적인 문자열 조작** 기법 활용