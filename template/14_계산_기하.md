# 📐 계산 기하 (Computational Geometry)

> **난이도**: Gold ~ Platinum  
> **대표 문제**: 11758(CCW), 17386(선분 교차 1), 2166(다각형의 넓이)

---

## 🎯 **핵심 개념**

계산 기하는 **기하학적 객체들의 관계**를 컴퓨터로 계산하는 분야입니다:
- **CCW (Counter-Clock Wise)**: 세 점의 회전 방향 판단
- **선분 교차**: 두 선분이 교차하는지 판단
- **볼록 껍질(Convex Hull)**: 점들을 둘러싸는 최소 볼록 다각형
- **점과 다각형**: 점이 다각형 내부에 있는지 판단

---

## 🔧 **기본 템플릿**

### **CCW (Counter-Clock Wise)**
```cpp
struct Point {
    long long x, y;
    
    Point(long long x = 0, long long y = 0) : x(x), y(y) {}
    
    Point operator-(const Point& other) const {
        return Point(x - other.x, y - other.y);
    }
    
    Point operator+(const Point& other) const {
        return Point(x + other.x, y + other.y);
    }
    
    long long cross(const Point& other) const {
        return x * other.y - y * other.x;
    }
    
    long long dot(const Point& other) const {
        return x * other.x + y * other.y;
    }
    
    bool operator<(const Point& other) const {
        return x < other.x || (x == other.x && y < other.y);
    }
    
    bool operator==(const Point& other) const {
        return x == other.x && y == other.y;
    }
};

// CCW: 반시계방향(1), 시계방향(-1), 일직선(0)
int ccw(const Point& a, const Point& b, const Point& c) {
    long long cross = (b - a).cross(c - a);
    if (cross > 0) return 1;   // 반시계방향
    if (cross < 0) return -1;  // 시계방향
    return 0;                  // 일직선
}

// 부호있는 넓이 (반시계방향이면 양수)
long long signedArea(const Point& a, const Point& b, const Point& c) {
    return (b - a).cross(c - a);
}

// 삼각형 넓이
double triangleArea(const Point& a, const Point& b, const Point& c) {
    return abs(signedArea(a, b, c)) / 2.0;
}
```

### **선분 교차**
```cpp
struct Segment {
    Point p1, p2;
    
    Segment(const Point& p1, const Point& p2) : p1(p1), p2(p2) {}
};

bool onSegment(const Point& p, const Point& q, const Point& r) {
    return q.x <= max(p.x, r.x) && q.x >= min(p.x, r.x) &&
           q.y <= max(p.y, r.y) && q.y >= min(p.y, r.y);
}

// 두 선분이 교차하는지 판단
bool segmentIntersect(const Segment& s1, const Segment& s2) {
    Point p1 = s1.p1, q1 = s1.p2;
    Point p2 = s2.p1, q2 = s2.p2;
    
    int o1 = ccw(p1, q1, p2);
    int o2 = ccw(p1, q1, q2);
    int o3 = ccw(p2, q2, p1);
    int o4 = ccw(p2, q2, q1);
    
    // 일반적인 경우
    if (o1 != o2 && o3 != o4) return true;
    
    // 특수한 경우 (한 점이 다른 선분 위에 있는 경우)
    if (o1 == 0 && onSegment(p1, p2, q1)) return true;
    if (o2 == 0 && onSegment(p1, q2, q1)) return true;
    if (o3 == 0 && onSegment(p2, p1, q2)) return true;
    if (o4 == 0 && onSegment(p2, q1, q2)) return true;
    
    return false;
}

// 두 선분의 교점 구하기 (교차할 때만)
Point getIntersection(const Segment& s1, const Segment& s2) {
    Point p1 = s1.p1, p2 = s1.p2;
    Point p3 = s2.p1, p4 = s2.p2;
    
    long long denom = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
    
    if (denom == 0) {
        // 평행한 경우 - 예외 처리 필요
        return Point(0, 0);
    }
    
    long long t_num = (p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x);
    
    // 실수 계산이 필요한 경우
    double t = (double)t_num / denom;
    
    return Point(p1.x + t * (p2.x - p1.x), p1.y + t * (p2.y - p1.y));
}
```

### **볼록 껍질 (Convex Hull)**
```cpp
// Graham Scan
vector<Point> convexHull(vector<Point> points) {
    int n = points.size();
    if (n <= 1) return points;
    
    // 가장 아래쪽(y가 작은), 같다면 가장 왼쪽(x가 작은) 점 찾기
    int minIdx = 0;
    for (int i = 1; i < n; i++) {
        if (points[i].y < points[minIdx].y || 
            (points[i].y == points[minIdx].y && points[i].x < points[minIdx].x)) {
            minIdx = i;
        }
    }
    swap(points[0], points[minIdx]);
    
    Point pivot = points[0];
    
    // 극각 정렬
    sort(points.begin() + 1, points.end(), [&](const Point& a, const Point& b) {
        int orientation = ccw(pivot, a, b);
        if (orientation == 0) {
            // 같은 각도면 거리가 가까운 것부터
            long long distA = (a.x - pivot.x) * (a.x - pivot.x) + (a.y - pivot.y) * (a.y - pivot.y);
            long long distB = (b.x - pivot.x) * (b.x - pivot.x) + (b.y - pivot.y) * (b.y - pivot.y);
            return distA < distB;
        }
        return orientation > 0;
    });
    
    // 스택으로 볼록 껍질 구성
    vector<Point> hull;
    hull.push_back(points[0]);
    hull.push_back(points[1]);
    
    for (int i = 2; i < n; i++) {
        while (hull.size() >= 2 && 
               ccw(hull[hull.size()-2], hull[hull.size()-1], points[i]) <= 0) {
            hull.pop_back();
        }
        hull.push_back(points[i]);
    }
    
    return hull;
}

// Andrew's Algorithm (더 안정적)
vector<Point> convexHullAndrew(vector<Point> points) {
    sort(points.begin(), points.end());
    points.erase(unique(points.begin(), points.end()), points.end());
    
    int n = points.size();
    if (n <= 1) return points;
    
    // 하단 껍질 구성
    vector<Point> lower;
    for (int i = 0; i < n; i++) {
        while (lower.size() >= 2 && 
               ccw(lower[lower.size()-2], lower[lower.size()-1], points[i]) <= 0) {
            lower.pop_back();
        }
        lower.push_back(points[i]);
    }
    
    // 상단 껍질 구성
    vector<Point> upper;
    for (int i = n - 1; i >= 0; i--) {
        while (upper.size() >= 2 && 
               ccw(upper[upper.size()-2], upper[upper.size()-1], points[i]) <= 0) {
            upper.pop_back();
        }
        upper.push_back(points[i]);
    }
    
    // 마지막 점 제거 (중복)
    lower.pop_back();
    upper.pop_back();
    
    // 합치기
    lower.insert(lower.end(), upper.begin(), upper.end());
    return lower;
}
```

### **다각형 관련 계산**
```cpp
// 다각형 넓이 (Shoelace formula)
double polygonArea(const vector<Point>& polygon) {
    int n = polygon.size();
    long long area = 0;
    
    for (int i = 0; i < n; i++) {
        int j = (i + 1) % n;
        area += polygon[i].x * polygon[j].y;
        area -= polygon[j].x * polygon[i].y;
    }
    
    return abs(area) / 2.0;
}

// 점이 다각형 내부에 있는지 판단 (Ray Casting)
bool pointInPolygon(const Point& p, const vector<Point>& polygon) {
    int n = polygon.size();
    bool inside = false;
    
    for (int i = 0, j = n - 1; i < n; j = i++) {
        if (((polygon[i].y > p.y) != (polygon[j].y > p.y)) &&
            (p.x < (polygon[j].x - polygon[i].x) * (p.y - polygon[i].y) / 
                   (polygon[j].y - polygon[i].y) + polygon[i].x)) {
            inside = !inside;
        }
    }
    
    return inside;
}

// 점이 다각형 경계에 있는지 판단
bool pointOnPolygonBoundary(const Point& p, const vector<Point>& polygon) {
    int n = polygon.size();
    
    for (int i = 0; i < n; i++) {
        int j = (i + 1) % n;
        Segment seg(polygon[i], polygon[j]);
        
        if (ccw(polygon[i], polygon[j], p) == 0 && 
            onSegment(polygon[i], p, polygon[j])) {
            return true;
        }
    }
    
    return false;
}

// 다각형이 볼록한지 판단
bool isConvex(const vector<Point>& polygon) {
    int n = polygon.size();
    if (n < 3) return false;
    
    bool hasPositive = false, hasNegative = false;
    
    for (int i = 0; i < n; i++) {
        int j = (i + 1) % n;
        int k = (i + 2) % n;
        
        int orientation = ccw(polygon[i], polygon[j], polygon[k]);
        
        if (orientation > 0) hasPositive = true;
        if (orientation < 0) hasNegative = true;
        
        if (hasPositive && hasNegative) return false;
    }
    
    return true;
}
```

---

## 💡 **고급 기법**

### **1. 회전하는 캘리퍼스 (Rotating Calipers)**
```cpp
// 볼록 다각형에서 가장 먼 두 점 사이의 거리
double farthestPairDistance(const vector<Point>& convexPolygon) {
    int n = convexPolygon.size();
    if (n <= 1) return 0;
    if (n == 2) {
        Point diff = convexPolygon[1] - convexPolygon[0];
        return sqrt(diff.dot(diff));
    }
    
    double maxDist = 0;
    int j = 1;
    
    for (int i = 0; i < n; i++) {
        int next_i = (i + 1) % n;
        
        // j를 최대한 멀리 이동
        while (true) {
            int next_j = (j + 1) % n;
            
            Point edge_i = convexPolygon[next_i] - convexPolygon[i];
            Point to_j = convexPolygon[j] - convexPolygon[i];
            Point to_next_j = convexPolygon[next_j] - convexPolygon[i];
            
            if (edge_i.cross(to_j) <= edge_i.cross(to_next_j)) {
                j = next_j;
            } else {
                break;
            }
        }
        
        Point diff = convexPolygon[j] - convexPolygon[i];
        maxDist = max(maxDist, sqrt(diff.dot(diff)));
    }
    
    return maxDist;
}

// 볼록 다각형에서 최소 넓이 직사각형
double minimumAreaRectangle(const vector<Point>& convexPolygon) {
    int n = convexPolygon.size();
    double minArea = 1e18;
    
    for (int i = 0; i < n; i++) {
        int next = (i + 1) % n;
        Point edge = convexPolygon[next] - convexPolygon[i];
        
        double width = 0, height = 0;
        
        for (const Point& p : convexPolygon) {
            Point vec = p - convexPolygon[i];
            
            // edge 방향 투영
            double proj = (double)(vec.dot(edge)) / sqrt(edge.dot(edge));
            width = max(width, proj);
            
            // edge에 수직 방향 투영
            double perp = abs((double)vec.cross(edge)) / sqrt(edge.dot(edge));
            height = max(height, perp);
        }
        
        minArea = min(minArea, width * height);
    }
    
    return minArea;
}
```

### **2. 보로노이 다이어그램과 들로네 삼각분할**
```cpp
// 세 점으로 이루어진 삼각형의 외심
Point circumcenter(const Point& a, const Point& b, const Point& c) {
    long long d = 2 * (a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y));
    
    if (d == 0) {
        // 일직선상의 점들 - 외심이 무한대
        return Point(0, 0);  // 에러 처리 필요
    }
    
    long long ux = (a.x * a.x + a.y * a.y) * (b.y - c.y) + 
                   (b.x * b.x + b.y * b.y) * (c.y - a.y) + 
                   (c.x * c.x + c.y * c.y) * (a.y - b.y);
    
    long long uy = (a.x * a.x + a.y * a.y) * (c.x - b.x) + 
                   (b.x * b.x + b.y * b.y) * (a.x - c.x) + 
                   (c.x * c.x + c.y * c.y) * (b.x - a.x);
    
    return Point(ux / d, uy / d);
}

// 점이 삼각형의 외접원 내부에 있는지 판단
bool inCircle(const Point& a, const Point& b, const Point& c, const Point& p) {
    Point center = circumcenter(a, b, c);
    
    long long radiusSq = (a.x - center.x) * (a.x - center.x) + 
                        (a.y - center.y) * (a.y - center.y);
    long long distSq = (p.x - center.x) * (p.x - center.x) + 
                      (p.y - center.y) * (p.y - center.y);
    
    return distSq < radiusSq;
}
```

---

## 🔍 **실제 예시**

### **예시 1: CCW (11758번)**
```cpp
#include <iostream>

struct Point {
    long long x, y;
};

int ccw(const Point& a, const Point& b, const Point& c) {
    long long cross = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
    
    if (cross > 0) return 1;   // 반시계방향
    if (cross < 0) return -1;  // 시계방향
    return 0;                  // 일직선
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    Point p1, p2, p3;
    cin >> p1.x >> p1.y;
    cin >> p2.x >> p2.y;
    cin >> p3.x >> p3.y;
    
    cout << ccw(p1, p2, p3) << "\n";
    
    return 0;
}
```

### **예시 2: 선분 교차 1 (17386번)**
```cpp
#include <iostream>
#include <algorithm>

struct Point {
    long long x, y;
};

int ccw(const Point& a, const Point& b, const Point& c) {
    long long cross = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
    if (cross > 0) return 1;
    if (cross < 0) return -1;
    return 0;
}

bool segmentIntersect(Point p1, Point q1, Point p2, Point q2) {
    int o1 = ccw(p1, q1, p2);
    int o2 = ccw(p1, q1, q2);
    int o3 = ccw(p2, q2, p1);
    int o4 = ccw(p2, q2, q1);
    
    return o1 != o2 && o3 != o4;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    Point p1, q1, p2, q2;
    cin >> p1.x >> p1.y >> q1.x >> q1.y;
    cin >> p2.x >> p2.y >> q2.x >> q2.y;
    
    cout << (segmentIntersect(p1, q1, p2, q2) ? 1 : 0) << "\n";
    
    return 0;
}
```

### **예시 3: 다각형의 넓이 (2166번)**
```cpp
#include <iostream>
#include <vector>
#include <cmath>

struct Point {
    long long x, y;
};

double polygonArea(const vector<Point>& polygon) {
    int n = polygon.size();
    long long area = 0;
    
    for (int i = 0; i < n; i++) {
        int j = (i + 1) % n;
        area += polygon[i].x * polygon[j].y;
        area -= polygon[j].x * polygon[i].y;
    }
    
    return abs(area) / 2.0;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    cin >> n;
    
    vector<Point> polygon(n);
    for (int i = 0; i < n; i++) {
        cin >> polygon[i].x >> polygon[i].y;
    }
    
    cout << fixed;
    cout.precision(1);
    cout << polygonArea(polygon) << "\n";
    
    return 0;
}
```

---

## ⚡ **최적화 팁**

### **1. 정밀도 관리**
```cpp
const double EPS = 1e-9;

bool isZero(double x) {
    return abs(x) < EPS;
}

bool isEqual(double a, double b) {
    return abs(a - b) < EPS;
}
```

### **2. 정수 연산 우선**
```cpp
// 가능한 한 정수 연산 사용
// 실수 연산은 최종 결과에서만
long long crossProduct(const Point& a, const Point& b) {
    return a.x * b.y - a.y * b.x;
}
```

### **3. 오버플로우 방지**
```cpp
// 중간 계산에서 오버플로우 방지
bool safeCross(const Point& a, const Point& b, const Point& c) {
    // __int128 사용 또는 분할 계산
    __int128 cross = (__int128)(b.x - a.x) * (c.y - a.y) - 
                     (__int128)(b.y - a.y) * (c.x - a.x);
    return cross != 0;
}
```

---

## 📊 **시간 복잡도**

### **기본 연산**
- **CCW**: O(1)
- **선분 교차**: O(1)
- **점-다각형 판정**: O(n)

### **고급 알고리즘**
- **볼록 껍질**: O(n log n)
- **회전하는 캘리퍼스**: O(n)
- **들로네 삼각분할**: O(n log n)

---

## 📝 **관련 문제**

### **기초**
- 11758: CCW
- 17386: 선분 교차 1
- 2166: 다각형의 넓이

### **볼록 껍질**
- 1708: 볼록 껍질
- 4225: 쓰레기 슈트

### **선분 교차**
- 17387: 선분 교차 2
- 2162: 선분 그룹

### **고급**
- 1067: 이동
- 3878: 점 분리
- 7869: 두 원

---

**🔑 핵심 포인트**:
- **CCW**가 모든 기하 알고리즘의 기초
- **정수 연산** 우선, **정밀도** 주의
- **특수 케이스** (일직선, 중복점) 처리
- **볼록 껍질**로 최적화 문제 해결