# ğŸ“ ê³„ì‚° ê¸°í•˜ (Computational Geometry)

> **ë‚œì´ë„**: Gold ~ Platinum  
> **ëŒ€í‘œ ë¬¸ì œ**: 11758(CCW), 17386(ì„ ë¶„ êµì°¨ 1), 2166(ë‹¤ê°í˜•ì˜ ë„“ì´)

---

## ğŸ¯ **í•µì‹¬ ê°œë…**

ê³„ì‚° ê¸°í•˜ëŠ” **ê¸°í•˜í•™ì  ê°ì²´ë“¤ì˜ ê´€ê³„**ë¥¼ ì»´í“¨í„°ë¡œ ê³„ì‚°í•˜ëŠ” ë¶„ì•¼ì…ë‹ˆë‹¤:
- **CCW (Counter-Clock Wise)**: ì„¸ ì ì˜ íšŒì „ ë°©í–¥ íŒë‹¨
- **ì„ ë¶„ êµì°¨**: ë‘ ì„ ë¶„ì´ êµì°¨í•˜ëŠ”ì§€ íŒë‹¨
- **ë³¼ë¡ ê»ì§ˆ(Convex Hull)**: ì ë“¤ì„ ë‘˜ëŸ¬ì‹¸ëŠ” ìµœì†Œ ë³¼ë¡ ë‹¤ê°í˜•
- **ì ê³¼ ë‹¤ê°í˜•**: ì ì´ ë‹¤ê°í˜• ë‚´ë¶€ì— ìˆëŠ”ì§€ íŒë‹¨

---

## ğŸ”§ **ê¸°ë³¸ í…œí”Œë¦¿**

### **CCW (Counter-Clock Wise)**
```cpp
struct Point {
    long long x, y;
    
    Point(long long x = 0, long long y = 0) : x(x), y(y) {}
    
    Point operator-(const Point& other) const {
        return Point(x - other.x, y - other.y);
    }
    
    Point operator+(const Point& other) const {
        return Point(x + other.x, y + other.y);
    }
    
    long long cross(const Point& other) const {
        return x * other.y - y * other.x;
    }
    
    long long dot(const Point& other) const {
        return x * other.x + y * other.y;
    }
    
    bool operator<(const Point& other) const {
        return x < other.x || (x == other.x && y < other.y);
    }
    
    bool operator==(const Point& other) const {
        return x == other.x && y == other.y;
    }
};

// CCW: ë°˜ì‹œê³„ë°©í–¥(1), ì‹œê³„ë°©í–¥(-1), ì¼ì§ì„ (0)
int ccw(const Point& a, const Point& b, const Point& c) {
    long long cross = (b - a).cross(c - a);
    if (cross > 0) return 1;   // ë°˜ì‹œê³„ë°©í–¥
    if (cross < 0) return -1;  // ì‹œê³„ë°©í–¥
    return 0;                  // ì¼ì§ì„ 
}

// ë¶€í˜¸ìˆëŠ” ë„“ì´ (ë°˜ì‹œê³„ë°©í–¥ì´ë©´ ì–‘ìˆ˜)
long long signedArea(const Point& a, const Point& b, const Point& c) {
    return (b - a).cross(c - a);
}

// ì‚¼ê°í˜• ë„“ì´
double triangleArea(const Point& a, const Point& b, const Point& c) {
    return abs(signedArea(a, b, c)) / 2.0;
}
```

### **ì„ ë¶„ êµì°¨**
```cpp
struct Segment {
    Point p1, p2;
    
    Segment(const Point& p1, const Point& p2) : p1(p1), p2(p2) {}
};

bool onSegment(const Point& p, const Point& q, const Point& r) {
    return q.x <= max(p.x, r.x) && q.x >= min(p.x, r.x) &&
           q.y <= max(p.y, r.y) && q.y >= min(p.y, r.y);
}

// ë‘ ì„ ë¶„ì´ êµì°¨í•˜ëŠ”ì§€ íŒë‹¨
bool segmentIntersect(const Segment& s1, const Segment& s2) {
    Point p1 = s1.p1, q1 = s1.p2;
    Point p2 = s2.p1, q2 = s2.p2;
    
    int o1 = ccw(p1, q1, p2);
    int o2 = ccw(p1, q1, q2);
    int o3 = ccw(p2, q2, p1);
    int o4 = ccw(p2, q2, q1);
    
    // ì¼ë°˜ì ì¸ ê²½ìš°
    if (o1 != o2 && o3 != o4) return true;
    
    // íŠ¹ìˆ˜í•œ ê²½ìš° (í•œ ì ì´ ë‹¤ë¥¸ ì„ ë¶„ ìœ„ì— ìˆëŠ” ê²½ìš°)
    if (o1 == 0 && onSegment(p1, p2, q1)) return true;
    if (o2 == 0 && onSegment(p1, q2, q1)) return true;
    if (o3 == 0 && onSegment(p2, p1, q2)) return true;
    if (o4 == 0 && onSegment(p2, q1, q2)) return true;
    
    return false;
}

// ë‘ ì„ ë¶„ì˜ êµì  êµ¬í•˜ê¸° (êµì°¨í•  ë•Œë§Œ)
Point getIntersection(const Segment& s1, const Segment& s2) {
    Point p1 = s1.p1, p2 = s1.p2;
    Point p3 = s2.p1, p4 = s2.p2;
    
    long long denom = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
    
    if (denom == 0) {
        // í‰í–‰í•œ ê²½ìš° - ì˜ˆì™¸ ì²˜ë¦¬ í•„ìš”
        return Point(0, 0);
    }
    
    long long t_num = (p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x);
    
    // ì‹¤ìˆ˜ ê³„ì‚°ì´ í•„ìš”í•œ ê²½ìš°
    double t = (double)t_num / denom;
    
    return Point(p1.x + t * (p2.x - p1.x), p1.y + t * (p2.y - p1.y));
}
```

### **ë³¼ë¡ ê»ì§ˆ (Convex Hull)**
```cpp
// Graham Scan
vector<Point> convexHull(vector<Point> points) {
    int n = points.size();
    if (n <= 1) return points;
    
    // ê°€ì¥ ì•„ë˜ìª½(yê°€ ì‘ì€), ê°™ë‹¤ë©´ ê°€ì¥ ì™¼ìª½(xê°€ ì‘ì€) ì  ì°¾ê¸°
    int minIdx = 0;
    for (int i = 1; i < n; i++) {
        if (points[i].y < points[minIdx].y || 
            (points[i].y == points[minIdx].y && points[i].x < points[minIdx].x)) {
            minIdx = i;
        }
    }
    swap(points[0], points[minIdx]);
    
    Point pivot = points[0];
    
    // ê·¹ê° ì •ë ¬
    sort(points.begin() + 1, points.end(), [&](const Point& a, const Point& b) {
        int orientation = ccw(pivot, a, b);
        if (orientation == 0) {
            // ê°™ì€ ê°ë„ë©´ ê±°ë¦¬ê°€ ê°€ê¹Œìš´ ê²ƒë¶€í„°
            long long distA = (a.x - pivot.x) * (a.x - pivot.x) + (a.y - pivot.y) * (a.y - pivot.y);
            long long distB = (b.x - pivot.x) * (b.x - pivot.x) + (b.y - pivot.y) * (b.y - pivot.y);
            return distA < distB;
        }
        return orientation > 0;
    });
    
    // ìŠ¤íƒìœ¼ë¡œ ë³¼ë¡ ê»ì§ˆ êµ¬ì„±
    vector<Point> hull;
    hull.push_back(points[0]);
    hull.push_back(points[1]);
    
    for (int i = 2; i < n; i++) {
        while (hull.size() >= 2 && 
               ccw(hull[hull.size()-2], hull[hull.size()-1], points[i]) <= 0) {
            hull.pop_back();
        }
        hull.push_back(points[i]);
    }
    
    return hull;
}

// Andrew's Algorithm (ë” ì•ˆì •ì )
vector<Point> convexHullAndrew(vector<Point> points) {
    sort(points.begin(), points.end());
    points.erase(unique(points.begin(), points.end()), points.end());
    
    int n = points.size();
    if (n <= 1) return points;
    
    // í•˜ë‹¨ ê»ì§ˆ êµ¬ì„±
    vector<Point> lower;
    for (int i = 0; i < n; i++) {
        while (lower.size() >= 2 && 
               ccw(lower[lower.size()-2], lower[lower.size()-1], points[i]) <= 0) {
            lower.pop_back();
        }
        lower.push_back(points[i]);
    }
    
    // ìƒë‹¨ ê»ì§ˆ êµ¬ì„±
    vector<Point> upper;
    for (int i = n - 1; i >= 0; i--) {
        while (upper.size() >= 2 && 
               ccw(upper[upper.size()-2], upper[upper.size()-1], points[i]) <= 0) {
            upper.pop_back();
        }
        upper.push_back(points[i]);
    }
    
    // ë§ˆì§€ë§‰ ì  ì œê±° (ì¤‘ë³µ)
    lower.pop_back();
    upper.pop_back();
    
    // í•©ì¹˜ê¸°
    lower.insert(lower.end(), upper.begin(), upper.end());
    return lower;
}
```

### **ë‹¤ê°í˜• ê´€ë ¨ ê³„ì‚°**
```cpp
// ë‹¤ê°í˜• ë„“ì´ (Shoelace formula)
double polygonArea(const vector<Point>& polygon) {
    int n = polygon.size();
    long long area = 0;
    
    for (int i = 0; i < n; i++) {
        int j = (i + 1) % n;
        area += polygon[i].x * polygon[j].y;
        area -= polygon[j].x * polygon[i].y;
    }
    
    return abs(area) / 2.0;
}

// ì ì´ ë‹¤ê°í˜• ë‚´ë¶€ì— ìˆëŠ”ì§€ íŒë‹¨ (Ray Casting)
bool pointInPolygon(const Point& p, const vector<Point>& polygon) {
    int n = polygon.size();
    bool inside = false;
    
    for (int i = 0, j = n - 1; i < n; j = i++) {
        if (((polygon[i].y > p.y) != (polygon[j].y > p.y)) &&
            (p.x < (polygon[j].x - polygon[i].x) * (p.y - polygon[i].y) / 
                   (polygon[j].y - polygon[i].y) + polygon[i].x)) {
            inside = !inside;
        }
    }
    
    return inside;
}

// ì ì´ ë‹¤ê°í˜• ê²½ê³„ì— ìˆëŠ”ì§€ íŒë‹¨
bool pointOnPolygonBoundary(const Point& p, const vector<Point>& polygon) {
    int n = polygon.size();
    
    for (int i = 0; i < n; i++) {
        int j = (i + 1) % n;
        Segment seg(polygon[i], polygon[j]);
        
        if (ccw(polygon[i], polygon[j], p) == 0 && 
            onSegment(polygon[i], p, polygon[j])) {
            return true;
        }
    }
    
    return false;
}

// ë‹¤ê°í˜•ì´ ë³¼ë¡í•œì§€ íŒë‹¨
bool isConvex(const vector<Point>& polygon) {
    int n = polygon.size();
    if (n < 3) return false;
    
    bool hasPositive = false, hasNegative = false;
    
    for (int i = 0; i < n; i++) {
        int j = (i + 1) % n;
        int k = (i + 2) % n;
        
        int orientation = ccw(polygon[i], polygon[j], polygon[k]);
        
        if (orientation > 0) hasPositive = true;
        if (orientation < 0) hasNegative = true;
        
        if (hasPositive && hasNegative) return false;
    }
    
    return true;
}
```

---

## ğŸ’¡ **ê³ ê¸‰ ê¸°ë²•**

### **1. íšŒì „í•˜ëŠ” ìº˜ë¦¬í¼ìŠ¤ (Rotating Calipers)**
```cpp
// ë³¼ë¡ ë‹¤ê°í˜•ì—ì„œ ê°€ì¥ ë¨¼ ë‘ ì  ì‚¬ì´ì˜ ê±°ë¦¬
double farthestPairDistance(const vector<Point>& convexPolygon) {
    int n = convexPolygon.size();
    if (n <= 1) return 0;
    if (n == 2) {
        Point diff = convexPolygon[1] - convexPolygon[0];
        return sqrt(diff.dot(diff));
    }
    
    double maxDist = 0;
    int j = 1;
    
    for (int i = 0; i < n; i++) {
        int next_i = (i + 1) % n;
        
        // jë¥¼ ìµœëŒ€í•œ ë©€ë¦¬ ì´ë™
        while (true) {
            int next_j = (j + 1) % n;
            
            Point edge_i = convexPolygon[next_i] - convexPolygon[i];
            Point to_j = convexPolygon[j] - convexPolygon[i];
            Point to_next_j = convexPolygon[next_j] - convexPolygon[i];
            
            if (edge_i.cross(to_j) <= edge_i.cross(to_next_j)) {
                j = next_j;
            } else {
                break;
            }
        }
        
        Point diff = convexPolygon[j] - convexPolygon[i];
        maxDist = max(maxDist, sqrt(diff.dot(diff)));
    }
    
    return maxDist;
}

// ë³¼ë¡ ë‹¤ê°í˜•ì—ì„œ ìµœì†Œ ë„“ì´ ì§ì‚¬ê°í˜•
double minimumAreaRectangle(const vector<Point>& convexPolygon) {
    int n = convexPolygon.size();
    double minArea = 1e18;
    
    for (int i = 0; i < n; i++) {
        int next = (i + 1) % n;
        Point edge = convexPolygon[next] - convexPolygon[i];
        
        double width = 0, height = 0;
        
        for (const Point& p : convexPolygon) {
            Point vec = p - convexPolygon[i];
            
            // edge ë°©í–¥ íˆ¬ì˜
            double proj = (double)(vec.dot(edge)) / sqrt(edge.dot(edge));
            width = max(width, proj);
            
            // edgeì— ìˆ˜ì§ ë°©í–¥ íˆ¬ì˜
            double perp = abs((double)vec.cross(edge)) / sqrt(edge.dot(edge));
            height = max(height, perp);
        }
        
        minArea = min(minArea, width * height);
    }
    
    return minArea;
}
```

### **2. ë³´ë¡œë…¸ì´ ë‹¤ì´ì–´ê·¸ë¨ê³¼ ë“¤ë¡œë„¤ ì‚¼ê°ë¶„í• **
```cpp
// ì„¸ ì ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ì‚¼ê°í˜•ì˜ ì™¸ì‹¬
Point circumcenter(const Point& a, const Point& b, const Point& c) {
    long long d = 2 * (a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y));
    
    if (d == 0) {
        // ì¼ì§ì„ ìƒì˜ ì ë“¤ - ì™¸ì‹¬ì´ ë¬´í•œëŒ€
        return Point(0, 0);  // ì—ëŸ¬ ì²˜ë¦¬ í•„ìš”
    }
    
    long long ux = (a.x * a.x + a.y * a.y) * (b.y - c.y) + 
                   (b.x * b.x + b.y * b.y) * (c.y - a.y) + 
                   (c.x * c.x + c.y * c.y) * (a.y - b.y);
    
    long long uy = (a.x * a.x + a.y * a.y) * (c.x - b.x) + 
                   (b.x * b.x + b.y * b.y) * (a.x - c.x) + 
                   (c.x * c.x + c.y * c.y) * (b.x - a.x);
    
    return Point(ux / d, uy / d);
}

// ì ì´ ì‚¼ê°í˜•ì˜ ì™¸ì ‘ì› ë‚´ë¶€ì— ìˆëŠ”ì§€ íŒë‹¨
bool inCircle(const Point& a, const Point& b, const Point& c, const Point& p) {
    Point center = circumcenter(a, b, c);
    
    long long radiusSq = (a.x - center.x) * (a.x - center.x) + 
                        (a.y - center.y) * (a.y - center.y);
    long long distSq = (p.x - center.x) * (p.x - center.x) + 
                      (p.y - center.y) * (p.y - center.y);
    
    return distSq < radiusSq;
}
```

---

## ğŸ” **ì‹¤ì œ ì˜ˆì‹œ**

### **ì˜ˆì‹œ 1: CCW (11758ë²ˆ)**
```cpp
#include <iostream>

struct Point {
    long long x, y;
};

int ccw(const Point& a, const Point& b, const Point& c) {
    long long cross = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
    
    if (cross > 0) return 1;   // ë°˜ì‹œê³„ë°©í–¥
    if (cross < 0) return -1;  // ì‹œê³„ë°©í–¥
    return 0;                  // ì¼ì§ì„ 
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    Point p1, p2, p3;
    cin >> p1.x >> p1.y;
    cin >> p2.x >> p2.y;
    cin >> p3.x >> p3.y;
    
    cout << ccw(p1, p2, p3) << "\n";
    
    return 0;
}
```

### **ì˜ˆì‹œ 2: ì„ ë¶„ êµì°¨ 1 (17386ë²ˆ)**
```cpp
#include <iostream>
#include <algorithm>

struct Point {
    long long x, y;
};

int ccw(const Point& a, const Point& b, const Point& c) {
    long long cross = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
    if (cross > 0) return 1;
    if (cross < 0) return -1;
    return 0;
}

bool segmentIntersect(Point p1, Point q1, Point p2, Point q2) {
    int o1 = ccw(p1, q1, p2);
    int o2 = ccw(p1, q1, q2);
    int o3 = ccw(p2, q2, p1);
    int o4 = ccw(p2, q2, q1);
    
    return o1 != o2 && o3 != o4;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    Point p1, q1, p2, q2;
    cin >> p1.x >> p1.y >> q1.x >> q1.y;
    cin >> p2.x >> p2.y >> q2.x >> q2.y;
    
    cout << (segmentIntersect(p1, q1, p2, q2) ? 1 : 0) << "\n";
    
    return 0;
}
```

### **ì˜ˆì‹œ 3: ë‹¤ê°í˜•ì˜ ë„“ì´ (2166ë²ˆ)**
```cpp
#include <iostream>
#include <vector>
#include <cmath>

struct Point {
    long long x, y;
};

double polygonArea(const vector<Point>& polygon) {
    int n = polygon.size();
    long long area = 0;
    
    for (int i = 0; i < n; i++) {
        int j = (i + 1) % n;
        area += polygon[i].x * polygon[j].y;
        area -= polygon[j].x * polygon[i].y;
    }
    
    return abs(area) / 2.0;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    cin >> n;
    
    vector<Point> polygon(n);
    for (int i = 0; i < n; i++) {
        cin >> polygon[i].x >> polygon[i].y;
    }
    
    cout << fixed;
    cout.precision(1);
    cout << polygonArea(polygon) << "\n";
    
    return 0;
}
```

---

## âš¡ **ìµœì í™” íŒ**

### **1. ì •ë°€ë„ ê´€ë¦¬**
```cpp
const double EPS = 1e-9;

bool isZero(double x) {
    return abs(x) < EPS;
}

bool isEqual(double a, double b) {
    return abs(a - b) < EPS;
}
```

### **2. ì •ìˆ˜ ì—°ì‚° ìš°ì„ **
```cpp
// ê°€ëŠ¥í•œ í•œ ì •ìˆ˜ ì—°ì‚° ì‚¬ìš©
// ì‹¤ìˆ˜ ì—°ì‚°ì€ ìµœì¢… ê²°ê³¼ì—ì„œë§Œ
long long crossProduct(const Point& a, const Point& b) {
    return a.x * b.y - a.y * b.x;
}
```

### **3. ì˜¤ë²„í”Œë¡œìš° ë°©ì§€**
```cpp
// ì¤‘ê°„ ê³„ì‚°ì—ì„œ ì˜¤ë²„í”Œë¡œìš° ë°©ì§€
bool safeCross(const Point& a, const Point& b, const Point& c) {
    // __int128 ì‚¬ìš© ë˜ëŠ” ë¶„í•  ê³„ì‚°
    __int128 cross = (__int128)(b.x - a.x) * (c.y - a.y) - 
                     (__int128)(b.y - a.y) * (c.x - a.x);
    return cross != 0;
}
```

---

## ğŸ“Š **ì‹œê°„ ë³µì¡ë„**

### **ê¸°ë³¸ ì—°ì‚°**
- **CCW**: O(1)
- **ì„ ë¶„ êµì°¨**: O(1)
- **ì -ë‹¤ê°í˜• íŒì •**: O(n)

### **ê³ ê¸‰ ì•Œê³ ë¦¬ì¦˜**
- **ë³¼ë¡ ê»ì§ˆ**: O(n log n)
- **íšŒì „í•˜ëŠ” ìº˜ë¦¬í¼ìŠ¤**: O(n)
- **ë“¤ë¡œë„¤ ì‚¼ê°ë¶„í• **: O(n log n)

---

## ğŸ“ **ê´€ë ¨ ë¬¸ì œ**

### **ê¸°ì´ˆ**
- 11758: CCW
- 17386: ì„ ë¶„ êµì°¨ 1
- 2166: ë‹¤ê°í˜•ì˜ ë„“ì´

### **ë³¼ë¡ ê»ì§ˆ**
- 1708: ë³¼ë¡ ê»ì§ˆ
- 4225: ì“°ë ˆê¸° ìŠˆíŠ¸

### **ì„ ë¶„ êµì°¨**
- 17387: ì„ ë¶„ êµì°¨ 2
- 2162: ì„ ë¶„ ê·¸ë£¹

### **ê³ ê¸‰**
- 1067: ì´ë™
- 3878: ì  ë¶„ë¦¬
- 7869: ë‘ ì›

---

**ğŸ”‘ í•µì‹¬ í¬ì¸íŠ¸**:
- **CCW**ê°€ ëª¨ë“  ê¸°í•˜ ì•Œê³ ë¦¬ì¦˜ì˜ ê¸°ì´ˆ
- **ì •ìˆ˜ ì—°ì‚°** ìš°ì„ , **ì •ë°€ë„** ì£¼ì˜
- **íŠ¹ìˆ˜ ì¼€ì´ìŠ¤** (ì¼ì§ì„ , ì¤‘ë³µì ) ì²˜ë¦¬
- **ë³¼ë¡ ê»ì§ˆ**ë¡œ ìµœì í™” ë¬¸ì œ í•´ê²°