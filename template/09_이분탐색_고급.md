# 🎯 고급 이분탐색

> **난이도**: Gold ~ Platinum  
> **대표 문제**: 1654(랜선 자르기), 12015(가장 긴 증가하는 부분 수열 2), 2110(공유기 설치)

---

## 🎯 **핵심 개념**

고급 이분탐색은 **매개변수 탐색**과 **최적화 문제**에 활용됩니다:
- **매개변수 탐색**: 조건을 만족하는 최적값 찾기
- **LIS (Longest Increasing Subsequence)**: 이분탐색으로 O(n log n) 해결
- **삼분 탐색**: 볼록/오목 함수의 최댓값/최솟값 찾기
- **실수 이분탐색**: 연속 함수에서의 근 찾기

---

## 🔧 **기본 템플릿**

### **매개변수 탐색 (Parametric Search)**
```cpp
// 조건을 만족하는 최솟값 찾기
bool isValid(int mid, const vector<int>& arr, int condition) {
    // mid 값으로 조건을 만족할 수 있는지 확인
    // 구체적인 구현은 문제에 따라 달라짐
    return true;  // 예시
}

int parametricSearch(const vector<int>& arr, int left, int right, int condition) {
    int answer = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (isValid(mid, arr, condition)) {
            answer = mid;
            right = mid - 1;  // 더 작은 값도 가능한지 확인
        } else {
            left = mid + 1;   // 더 큰 값 필요
        }
    }
    
    return answer;
}

// 조건을 만족하는 최댓값 찾기
int parametricSearchMax(const vector<int>& arr, int left, int right, int condition) {
    int answer = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (isValid(mid, arr, condition)) {
            answer = mid;
            left = mid + 1;   // 더 큰 값도 가능한지 확인
        } else {
            right = mid - 1;  // 더 작은 값 필요
        }
    }
    
    return answer;
}
```

### **LIS (가장 긴 증가하는 부분 수열)**
```cpp
// O(n log n) LIS 길이 구하기
int lisLength(const vector<int>& arr) {
    vector<int> lis;
    
    for (int x : arr) {
        auto pos = lower_bound(lis.begin(), lis.end(), x);
        
        if (pos == lis.end()) {
            lis.push_back(x);
        } else {
            *pos = x;
        }
    }
    
    return lis.size();
}

// LIS 복원하기
vector<int> reconstructLIS(const vector<int>& arr) {
    int n = arr.size();
    vector<int> lis;
    vector<int> parent(n, -1);
    vector<int> lisIndex(n);
    
    for (int i = 0; i < n; i++) {
        auto pos = lower_bound(lis.begin(), lis.end(), arr[i]);
        int idx = pos - lis.begin();
        
        if (pos == lis.end()) {
            lis.push_back(arr[i]);
        } else {
            *pos = arr[i];
        }
        
        lisIndex[i] = idx;
        if (idx > 0) {
            // 이전 LIS에서 마지막 원소 찾기
            for (int j = i - 1; j >= 0; j--) {
                if (lisIndex[j] == idx - 1 && arr[j] < arr[i]) {
                    parent[i] = j;
                    break;
                }
            }
        }
    }
    
    // LIS 복원
    vector<int> result;
    int maxLen = lis.size();
    
    // 마지막 원소 찾기
    int lastIdx = -1;
    for (int i = n - 1; i >= 0; i--) {
        if (lisIndex[i] == maxLen - 1) {
            lastIdx = i;
            break;
        }
    }
    
    // 역추적
    for (int curr = lastIdx; curr != -1; curr = parent[curr]) {
        result.push_back(arr[curr]);
    }
    
    reverse(result.begin(), result.end());
    return result;
}
```

### **삼분 탐색 (Ternary Search)**
```cpp
// 볼록 함수의 최댓값 찾기 (정수)
int ternarySearchInt(int left, int right, function<int(int)> f) {
    while (right - left > 2) {
        int m1 = left + (right - left) / 3;
        int m2 = right - (right - left) / 3;
        
        if (f(m1) > f(m2)) {
            right = m2;
        } else {
            left = m1;
        }
    }
    
    int maxVal = f(left);
    int result = left;
    
    for (int i = left; i <= right; i++) {
        if (f(i) > maxVal) {
            maxVal = f(i);
            result = i;
        }
    }
    
    return result;
}

// 볼록 함수의 최댓값 찾기 (실수)
double ternarySearchDouble(double left, double right, function<double(double)> f) {
    const double EPS = 1e-9;
    
    while (right - left > EPS) {
        double m1 = left + (right - left) / 3.0;
        double m2 = right - (right - left) / 3.0;
        
        if (f(m1) > f(m2)) {
            right = m2;
        } else {
            left = m1;
        }
    }
    
    return (left + right) / 2.0;
}
```

### **실수 이분탐색**
```cpp
// 실수 범위에서 조건을 만족하는 값 찾기
double binarySearchDouble(double left, double right, function<bool(double)> isValid) {
    const double EPS = 1e-9;
    
    while (right - left > EPS) {
        double mid = (left + right) / 2.0;
        
        if (isValid(mid)) {
            right = mid;
        } else {
            left = mid;
        }
    }
    
    return (left + right) / 2.0;
}

// 방정식의 근 찾기
double findRoot(double left, double right, function<double(double)> f) {
    const double EPS = 1e-9;
    
    while (right - left > EPS) {
        double mid = (left + right) / 2.0;
        
        if (f(left) * f(mid) <= 0) {
            right = mid;
        } else {
            left = mid;
        }
    }
    
    return (left + right) / 2.0;
}
```

---

## 💡 **고급 패턴**

### **1. 2D 이분탐색**
```cpp
// 2차원 배열에서 k번째 작은 수 찾기
int kthSmallest2D(vector<vector<int>>& matrix, int k) {
    int n = matrix.size();
    int left = matrix[0][0];
    int right = matrix[n-1][n-1];
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        int count = 0;
        
        // mid 이하인 원소의 개수 세기
        int j = n - 1;
        for (int i = 0; i < n; i++) {
            while (j >= 0 && matrix[i][j] > mid) {
                j--;
            }
            count += j + 1;
        }
        
        if (count < k) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    
    return left;
}
```

### **2. 분수 이분탐색**
```cpp
struct Fraction {
    long long num, den;
    
    Fraction(long long n, long long d) : num(n), den(d) {
        if (den < 0) {
            num = -num;
            den = -den;
        }
    }
    
    bool operator<(const Fraction& other) const {
        return num * other.den < other.num * den;
    }
    
    bool operator==(const Fraction& other) const {
        return num * other.den == other.num * den;
    }
};

// 분수 범위에서 조건을 만족하는 값 찾기
Fraction binarySearchFraction(Fraction left, Fraction right, 
                             function<bool(Fraction)> isValid) {
    while (!(left == right)) {
        Fraction mid(left.num + right.num, left.den + right.den);
        
        if (isValid(mid)) {
            right = mid;
        } else {
            left = mid;
        }
    }
    
    return left;
}
```

### **3. 병렬 이분탐색**
```cpp
// 여러 쿼리를 동시에 처리
struct Query {
    int left, right, answer, id;
};

void parallelBinarySearch(vector<Query>& queries, vector<int>& events) {
    function<void(vector<int>&, int, int)> solve = [&](vector<int>& qids, int left, int right) {
        if (left == right) {
            for (int qid : qids) {
                queries[qid].answer = left;
            }
            return;
        }
        
        int mid = (left + right) / 2;
        vector<int> leftQueries, rightQueries;
        
        // mid까지의 이벤트 적용
        for (int i = 0; i <= mid; i++) {
            applyEvent(events[i]);
        }
        
        for (int qid : qids) {
            if (checkQuery(queries[qid])) {
                rightQueries.push_back(qid);
            } else {
                leftQueries.push_back(qid);
            }
        }
        
        // 이벤트 롤백
        for (int i = mid; i >= 0; i--) {
            rollbackEvent(events[i]);
        }
        
        solve(leftQueries, left, mid);
        solve(rightQueries, mid + 1, right);
    };
    
    vector<int> allQueries(queries.size());
    iota(allQueries.begin(), allQueries.end(), 0);
    solve(allQueries, 0, events.size() - 1);
}
```

---

## 🔍 **실제 예시**

### **예시 1: 랜선 자르기 (1654번)**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool canMake(const vector<int>& cables, int length, int n) {
    int count = 0;
    for (int cable : cables) {
        count += cable / length;
        if (count >= n) return true;
    }
    return false;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int k, n;
    cin >> k >> n;
    
    vector<int> cables(k);
    int maxLength = 0;
    
    for (int i = 0; i < k; i++) {
        cin >> cables[i];
        maxLength = max(maxLength, cables[i]);
    }
    
    int left = 1, right = maxLength;
    int answer = 0;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (canMake(cables, mid, n)) {
            answer = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    cout << answer << "\n";
    
    return 0;
}
```

### **예시 2: 가장 긴 증가하는 부분 수열 2 (12015번)**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    cin >> n;
    
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    
    vector<int> lis;
    
    for (int x : arr) {
        auto pos = lower_bound(lis.begin(), lis.end(), x);
        
        if (pos == lis.end()) {
            lis.push_back(x);
        } else {
            *pos = x;
        }
    }
    
    cout << lis.size() << "\n";
    
    return 0;
}
```

### **예시 3: 공유기 설치 (2110번)**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool canInstall(const vector<int>& houses, int distance, int c) {
    int count = 1;
    int lastPos = houses[0];
    
    for (int i = 1; i < houses.size(); i++) {
        if (houses[i] - lastPos >= distance) {
            count++;
            lastPos = houses[i];
            if (count >= c) return true;
        }
    }
    
    return false;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, c;
    cin >> n >> c;
    
    vector<int> houses(n);
    for (int i = 0; i < n; i++) {
        cin >> houses[i];
    }
    
    sort(houses.begin(), houses.end());
    
    int left = 1;
    int right = houses[n-1] - houses[0];
    int answer = 0;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (canInstall(houses, mid, c)) {
            answer = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    cout << answer << "\n";
    
    return 0;
}
```

---

## ⚡ **최적화 기법**

### **1. 이분탐색 경계 최적화**
```cpp
// 무한대 대신 실제 범위 계산
int findUpperBound(const vector<int>& arr, function<bool(int)> isValid) {
    int bound = 1;
    while (isValid(bound)) {
        bound *= 2;
    }
    return bound;
}
```

### **2. 정밀도 최적화**
```cpp
// 고정 반복 횟수로 정밀도 보장
double binarySearchFixed(double left, double right, function<bool(double)> isValid) {
    for (int iter = 0; iter < 100; iter++) {  // log2(범위) + 여유분
        double mid = (left + right) / 2.0;
        if (isValid(mid)) {
            right = mid;
        } else {
            left = mid;
        }
    }
    return (left + right) / 2.0;
}
```

### **3. 캐싱 최적화**
```cpp
// 중복 계산 방지를 위한 메모이제이션
unordered_map<int, bool> cache;

bool isValidCached(int value) {
    if (cache.count(value)) {
        return cache[value];
    }
    return cache[value] = expensiveCheck(value);
}
```

---

## 📊 **시간 복잡도**

- **매개변수 탐색**: O(log(범위) × 검증함수복잡도)
- **LIS**: O(n log n)
- **삼분 탐색**: O(log(범위) × 함수계산복잡도)
- **2D 이분탐색**: O(n log(최댓값))

---

## 📝 **관련 문제**

### **매개변수 탐색**
- 1654: 랜선 자르기
- 2110: 공유기 설치
- 2512: 예산
- 1300: K번째 수

### **LIS**
- 12015: 가장 긴 증가하는 부분 수열 2
- 12738: 가장 긴 증가하는 부분 수열 3
- 14003: 가장 긴 증가하는 부분 수열 5

### **삼분 탐색**
- 11662: 민호와 강호
- 2844: 최적의 행렬 곱셈

### **고급 응용**
- 1561: 놀이 공원
- 2143: 두 배열의 합

---

**🔑 핵심 포인트**:
- **조건 함수** 정확히 구현하기
- **경계값** 처리 주의
- **오버플로우** 방지
- **실수 정밀도** 고려