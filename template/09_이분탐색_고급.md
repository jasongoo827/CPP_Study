# ğŸ¯ ê³ ê¸‰ ì´ë¶„íƒìƒ‰

> **ë‚œì´ë„**: Gold ~ Platinum  
> **ëŒ€í‘œ ë¬¸ì œ**: 1654(ëœì„  ìë¥´ê¸°), 12015(ê°€ì¥ ê¸´ ì¦ê°€í•˜ëŠ” ë¶€ë¶„ ìˆ˜ì—´ 2), 2110(ê³µìœ ê¸° ì„¤ì¹˜)

---

## ğŸ¯ **í•µì‹¬ ê°œë…**

ê³ ê¸‰ ì´ë¶„íƒìƒ‰ì€ **ë§¤ê°œë³€ìˆ˜ íƒìƒ‰**ê³¼ **ìµœì í™” ë¬¸ì œ**ì— í™œìš©ë©ë‹ˆë‹¤:
- **ë§¤ê°œë³€ìˆ˜ íƒìƒ‰**: ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ìµœì ê°’ ì°¾ê¸°
- **LIS (Longest Increasing Subsequence)**: ì´ë¶„íƒìƒ‰ìœ¼ë¡œ O(n log n) í•´ê²°
- **ì‚¼ë¶„ íƒìƒ‰**: ë³¼ë¡/ì˜¤ëª© í•¨ìˆ˜ì˜ ìµœëŒ“ê°’/ìµœì†Ÿê°’ ì°¾ê¸°
- **ì‹¤ìˆ˜ ì´ë¶„íƒìƒ‰**: ì—°ì† í•¨ìˆ˜ì—ì„œì˜ ê·¼ ì°¾ê¸°

---

## ğŸ”§ **ê¸°ë³¸ í…œí”Œë¦¿**

### **ë§¤ê°œë³€ìˆ˜ íƒìƒ‰ (Parametric Search)**
```cpp
// ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ìµœì†Ÿê°’ ì°¾ê¸°
bool isValid(int mid, const vector<int>& arr, int condition) {
    // mid ê°’ìœ¼ë¡œ ì¡°ê±´ì„ ë§Œì¡±í•  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸
    // êµ¬ì²´ì ì¸ êµ¬í˜„ì€ ë¬¸ì œì— ë”°ë¼ ë‹¬ë¼ì§
    return true;  // ì˜ˆì‹œ
}

int parametricSearch(const vector<int>& arr, int left, int right, int condition) {
    int answer = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (isValid(mid, arr, condition)) {
            answer = mid;
            right = mid - 1;  // ë” ì‘ì€ ê°’ë„ ê°€ëŠ¥í•œì§€ í™•ì¸
        } else {
            left = mid + 1;   // ë” í° ê°’ í•„ìš”
        }
    }
    
    return answer;
}

// ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ìµœëŒ“ê°’ ì°¾ê¸°
int parametricSearchMax(const vector<int>& arr, int left, int right, int condition) {
    int answer = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (isValid(mid, arr, condition)) {
            answer = mid;
            left = mid + 1;   // ë” í° ê°’ë„ ê°€ëŠ¥í•œì§€ í™•ì¸
        } else {
            right = mid - 1;  // ë” ì‘ì€ ê°’ í•„ìš”
        }
    }
    
    return answer;
}
```

### **LIS (ê°€ì¥ ê¸´ ì¦ê°€í•˜ëŠ” ë¶€ë¶„ ìˆ˜ì—´)**
```cpp
// O(n log n) LIS ê¸¸ì´ êµ¬í•˜ê¸°
int lisLength(const vector<int>& arr) {
    vector<int> lis;
    
    for (int x : arr) {
        auto pos = lower_bound(lis.begin(), lis.end(), x);
        
        if (pos == lis.end()) {
            lis.push_back(x);
        } else {
            *pos = x;
        }
    }
    
    return lis.size();
}

// LIS ë³µì›í•˜ê¸°
vector<int> reconstructLIS(const vector<int>& arr) {
    int n = arr.size();
    vector<int> lis;
    vector<int> parent(n, -1);
    vector<int> lisIndex(n);
    
    for (int i = 0; i < n; i++) {
        auto pos = lower_bound(lis.begin(), lis.end(), arr[i]);
        int idx = pos - lis.begin();
        
        if (pos == lis.end()) {
            lis.push_back(arr[i]);
        } else {
            *pos = arr[i];
        }
        
        lisIndex[i] = idx;
        if (idx > 0) {
            // ì´ì „ LISì—ì„œ ë§ˆì§€ë§‰ ì›ì†Œ ì°¾ê¸°
            for (int j = i - 1; j >= 0; j--) {
                if (lisIndex[j] == idx - 1 && arr[j] < arr[i]) {
                    parent[i] = j;
                    break;
                }
            }
        }
    }
    
    // LIS ë³µì›
    vector<int> result;
    int maxLen = lis.size();
    
    // ë§ˆì§€ë§‰ ì›ì†Œ ì°¾ê¸°
    int lastIdx = -1;
    for (int i = n - 1; i >= 0; i--) {
        if (lisIndex[i] == maxLen - 1) {
            lastIdx = i;
            break;
        }
    }
    
    // ì—­ì¶”ì 
    for (int curr = lastIdx; curr != -1; curr = parent[curr]) {
        result.push_back(arr[curr]);
    }
    
    reverse(result.begin(), result.end());
    return result;
}
```

### **ì‚¼ë¶„ íƒìƒ‰ (Ternary Search)**
```cpp
// ë³¼ë¡ í•¨ìˆ˜ì˜ ìµœëŒ“ê°’ ì°¾ê¸° (ì •ìˆ˜)
int ternarySearchInt(int left, int right, function<int(int)> f) {
    while (right - left > 2) {
        int m1 = left + (right - left) / 3;
        int m2 = right - (right - left) / 3;
        
        if (f(m1) > f(m2)) {
            right = m2;
        } else {
            left = m1;
        }
    }
    
    int maxVal = f(left);
    int result = left;
    
    for (int i = left; i <= right; i++) {
        if (f(i) > maxVal) {
            maxVal = f(i);
            result = i;
        }
    }
    
    return result;
}

// ë³¼ë¡ í•¨ìˆ˜ì˜ ìµœëŒ“ê°’ ì°¾ê¸° (ì‹¤ìˆ˜)
double ternarySearchDouble(double left, double right, function<double(double)> f) {
    const double EPS = 1e-9;
    
    while (right - left > EPS) {
        double m1 = left + (right - left) / 3.0;
        double m2 = right - (right - left) / 3.0;
        
        if (f(m1) > f(m2)) {
            right = m2;
        } else {
            left = m1;
        }
    }
    
    return (left + right) / 2.0;
}
```

### **ì‹¤ìˆ˜ ì´ë¶„íƒìƒ‰**
```cpp
// ì‹¤ìˆ˜ ë²”ìœ„ì—ì„œ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ê°’ ì°¾ê¸°
double binarySearchDouble(double left, double right, function<bool(double)> isValid) {
    const double EPS = 1e-9;
    
    while (right - left > EPS) {
        double mid = (left + right) / 2.0;
        
        if (isValid(mid)) {
            right = mid;
        } else {
            left = mid;
        }
    }
    
    return (left + right) / 2.0;
}

// ë°©ì •ì‹ì˜ ê·¼ ì°¾ê¸°
double findRoot(double left, double right, function<double(double)> f) {
    const double EPS = 1e-9;
    
    while (right - left > EPS) {
        double mid = (left + right) / 2.0;
        
        if (f(left) * f(mid) <= 0) {
            right = mid;
        } else {
            left = mid;
        }
    }
    
    return (left + right) / 2.0;
}
```

---

## ğŸ’¡ **ê³ ê¸‰ íŒ¨í„´**

### **1. 2D ì´ë¶„íƒìƒ‰**
```cpp
// 2ì°¨ì› ë°°ì—´ì—ì„œ kë²ˆì§¸ ì‘ì€ ìˆ˜ ì°¾ê¸°
int kthSmallest2D(vector<vector<int>>& matrix, int k) {
    int n = matrix.size();
    int left = matrix[0][0];
    int right = matrix[n-1][n-1];
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        int count = 0;
        
        // mid ì´í•˜ì¸ ì›ì†Œì˜ ê°œìˆ˜ ì„¸ê¸°
        int j = n - 1;
        for (int i = 0; i < n; i++) {
            while (j >= 0 && matrix[i][j] > mid) {
                j--;
            }
            count += j + 1;
        }
        
        if (count < k) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    
    return left;
}
```

### **2. ë¶„ìˆ˜ ì´ë¶„íƒìƒ‰**
```cpp
struct Fraction {
    long long num, den;
    
    Fraction(long long n, long long d) : num(n), den(d) {
        if (den < 0) {
            num = -num;
            den = -den;
        }
    }
    
    bool operator<(const Fraction& other) const {
        return num * other.den < other.num * den;
    }
    
    bool operator==(const Fraction& other) const {
        return num * other.den == other.num * den;
    }
};

// ë¶„ìˆ˜ ë²”ìœ„ì—ì„œ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ê°’ ì°¾ê¸°
Fraction binarySearchFraction(Fraction left, Fraction right, 
                             function<bool(Fraction)> isValid) {
    while (!(left == right)) {
        Fraction mid(left.num + right.num, left.den + right.den);
        
        if (isValid(mid)) {
            right = mid;
        } else {
            left = mid;
        }
    }
    
    return left;
}
```

### **3. ë³‘ë ¬ ì´ë¶„íƒìƒ‰**
```cpp
// ì—¬ëŸ¬ ì¿¼ë¦¬ë¥¼ ë™ì‹œì— ì²˜ë¦¬
struct Query {
    int left, right, answer, id;
};

void parallelBinarySearch(vector<Query>& queries, vector<int>& events) {
    function<void(vector<int>&, int, int)> solve = [&](vector<int>& qids, int left, int right) {
        if (left == right) {
            for (int qid : qids) {
                queries[qid].answer = left;
            }
            return;
        }
        
        int mid = (left + right) / 2;
        vector<int> leftQueries, rightQueries;
        
        // midê¹Œì§€ì˜ ì´ë²¤íŠ¸ ì ìš©
        for (int i = 0; i <= mid; i++) {
            applyEvent(events[i]);
        }
        
        for (int qid : qids) {
            if (checkQuery(queries[qid])) {
                rightQueries.push_back(qid);
            } else {
                leftQueries.push_back(qid);
            }
        }
        
        // ì´ë²¤íŠ¸ ë¡¤ë°±
        for (int i = mid; i >= 0; i--) {
            rollbackEvent(events[i]);
        }
        
        solve(leftQueries, left, mid);
        solve(rightQueries, mid + 1, right);
    };
    
    vector<int> allQueries(queries.size());
    iota(allQueries.begin(), allQueries.end(), 0);
    solve(allQueries, 0, events.size() - 1);
}
```

---

## ğŸ” **ì‹¤ì œ ì˜ˆì‹œ**

### **ì˜ˆì‹œ 1: ëœì„  ìë¥´ê¸° (1654ë²ˆ)**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool canMake(const vector<int>& cables, int length, int n) {
    int count = 0;
    for (int cable : cables) {
        count += cable / length;
        if (count >= n) return true;
    }
    return false;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int k, n;
    cin >> k >> n;
    
    vector<int> cables(k);
    int maxLength = 0;
    
    for (int i = 0; i < k; i++) {
        cin >> cables[i];
        maxLength = max(maxLength, cables[i]);
    }
    
    int left = 1, right = maxLength;
    int answer = 0;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (canMake(cables, mid, n)) {
            answer = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    cout << answer << "\n";
    
    return 0;
}
```

### **ì˜ˆì‹œ 2: ê°€ì¥ ê¸´ ì¦ê°€í•˜ëŠ” ë¶€ë¶„ ìˆ˜ì—´ 2 (12015ë²ˆ)**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    cin >> n;
    
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    
    vector<int> lis;
    
    for (int x : arr) {
        auto pos = lower_bound(lis.begin(), lis.end(), x);
        
        if (pos == lis.end()) {
            lis.push_back(x);
        } else {
            *pos = x;
        }
    }
    
    cout << lis.size() << "\n";
    
    return 0;
}
```

### **ì˜ˆì‹œ 3: ê³µìœ ê¸° ì„¤ì¹˜ (2110ë²ˆ)**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool canInstall(const vector<int>& houses, int distance, int c) {
    int count = 1;
    int lastPos = houses[0];
    
    for (int i = 1; i < houses.size(); i++) {
        if (houses[i] - lastPos >= distance) {
            count++;
            lastPos = houses[i];
            if (count >= c) return true;
        }
    }
    
    return false;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, c;
    cin >> n >> c;
    
    vector<int> houses(n);
    for (int i = 0; i < n; i++) {
        cin >> houses[i];
    }
    
    sort(houses.begin(), houses.end());
    
    int left = 1;
    int right = houses[n-1] - houses[0];
    int answer = 0;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (canInstall(houses, mid, c)) {
            answer = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    cout << answer << "\n";
    
    return 0;
}
```

---

## âš¡ **ìµœì í™” ê¸°ë²•**

### **1. ì´ë¶„íƒìƒ‰ ê²½ê³„ ìµœì í™”**
```cpp
// ë¬´í•œëŒ€ ëŒ€ì‹  ì‹¤ì œ ë²”ìœ„ ê³„ì‚°
int findUpperBound(const vector<int>& arr, function<bool(int)> isValid) {
    int bound = 1;
    while (isValid(bound)) {
        bound *= 2;
    }
    return bound;
}
```

### **2. ì •ë°€ë„ ìµœì í™”**
```cpp
// ê³ ì • ë°˜ë³µ íšŸìˆ˜ë¡œ ì •ë°€ë„ ë³´ì¥
double binarySearchFixed(double left, double right, function<bool(double)> isValid) {
    for (int iter = 0; iter < 100; iter++) {  // log2(ë²”ìœ„) + ì—¬ìœ ë¶„
        double mid = (left + right) / 2.0;
        if (isValid(mid)) {
            right = mid;
        } else {
            left = mid;
        }
    }
    return (left + right) / 2.0;
}
```

### **3. ìºì‹± ìµœì í™”**
```cpp
// ì¤‘ë³µ ê³„ì‚° ë°©ì§€ë¥¼ ìœ„í•œ ë©”ëª¨ì´ì œì´ì…˜
unordered_map<int, bool> cache;

bool isValidCached(int value) {
    if (cache.count(value)) {
        return cache[value];
    }
    return cache[value] = expensiveCheck(value);
}
```

---

## ğŸ“Š **ì‹œê°„ ë³µì¡ë„**

- **ë§¤ê°œë³€ìˆ˜ íƒìƒ‰**: O(log(ë²”ìœ„) Ã— ê²€ì¦í•¨ìˆ˜ë³µì¡ë„)
- **LIS**: O(n log n)
- **ì‚¼ë¶„ íƒìƒ‰**: O(log(ë²”ìœ„) Ã— í•¨ìˆ˜ê³„ì‚°ë³µì¡ë„)
- **2D ì´ë¶„íƒìƒ‰**: O(n log(ìµœëŒ“ê°’))

---

## ğŸ“ **ê´€ë ¨ ë¬¸ì œ**

### **ë§¤ê°œë³€ìˆ˜ íƒìƒ‰**
- 1654: ëœì„  ìë¥´ê¸°
- 2110: ê³µìœ ê¸° ì„¤ì¹˜
- 2512: ì˜ˆì‚°
- 1300: Kë²ˆì§¸ ìˆ˜

### **LIS**
- 12015: ê°€ì¥ ê¸´ ì¦ê°€í•˜ëŠ” ë¶€ë¶„ ìˆ˜ì—´ 2
- 12738: ê°€ì¥ ê¸´ ì¦ê°€í•˜ëŠ” ë¶€ë¶„ ìˆ˜ì—´ 3
- 14003: ê°€ì¥ ê¸´ ì¦ê°€í•˜ëŠ” ë¶€ë¶„ ìˆ˜ì—´ 5

### **ì‚¼ë¶„ íƒìƒ‰**
- 11662: ë¯¼í˜¸ì™€ ê°•í˜¸
- 2844: ìµœì ì˜ í–‰ë ¬ ê³±ì…ˆ

### **ê³ ê¸‰ ì‘ìš©**
- 1561: ë†€ì´ ê³µì›
- 2143: ë‘ ë°°ì—´ì˜ í•©

---

**ğŸ”‘ í•µì‹¬ í¬ì¸íŠ¸**:
- **ì¡°ê±´ í•¨ìˆ˜** ì •í™•íˆ êµ¬í˜„í•˜ê¸°
- **ê²½ê³„ê°’** ì²˜ë¦¬ ì£¼ì˜
- **ì˜¤ë²„í”Œë¡œìš°** ë°©ì§€
- **ì‹¤ìˆ˜ ì •ë°€ë„** ê³ ë ¤