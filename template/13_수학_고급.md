# ğŸ§® ê³ ê¸‰ ìˆ˜í•™

> **ë‚œì´ë„**: Gold ~ Platinum  
> **ëŒ€í‘œ ë¬¸ì œ**: 1629(ê³±ì…ˆ), 11401(ì´í•­ ê³„ìˆ˜ 3), 2749(í”¼ë³´ë‚˜ì¹˜ ìˆ˜ 3)

---

## ğŸ¯ **í•µì‹¬ ê°œë…**

ê³ ê¸‰ ìˆ˜í•™ì€ **ìˆ˜ë¡ ê³¼ ì¡°í•©ë¡ ì˜ íš¨ìœ¨ì  ê³„ì‚°**ì„ ë‹¤ë£¹ë‹ˆë‹¤:
- **ë¹ ë¥¸ ê±°ë“­ì œê³±(Fast Exponentiation)**: O(log n) ê±°ë“­ì œê³±
- **ëª¨ë“ˆëŸ¬ ì—°ì‚°**: í° ìˆ˜ì˜ ë‚˜ë¨¸ì§€ ê³„ì‚°
- **í™•ì¥ ìœ í´ë¦¬ë“œ í˜¸ì œë²•**: ì—­ì› ê³„ì‚°
- **í–‰ë ¬ ê±°ë“­ì œê³±**: ì í™”ì‹ ê°€ì†í™”

---

## ğŸ”§ **ê¸°ë³¸ í…œí”Œë¦¿**

### **ë¹ ë¥¸ ê±°ë“­ì œê³±**
```cpp
// ê¸°ë³¸ ë¹ ë¥¸ ê±°ë“­ì œê³±
long long fastPower(long long base, long long exp, long long mod) {
    long long result = 1;
    base %= mod;
    
    while (exp > 0) {
        if (exp & 1) {
            result = (result * base) % mod;
        }
        base = (base * base) % mod;
        exp >>= 1;
    }
    
    return result;
}

// ì¬ê·€ ë²„ì „
long long fastPowerRecursive(long long base, long long exp, long long mod) {
    if (exp == 0) return 1;
    
    long long half = fastPowerRecursive(base, exp / 2, mod);
    half = (half * half) % mod;
    
    if (exp & 1) {
        half = (half * base) % mod;
    }
    
    return half;
}

// ëª¨ë“ˆëŸ¬ ì—­ì› ê³„ì‚° (modê°€ ì†Œìˆ˜ì¼ ë•Œ)
long long modInverse(long long a, long long mod) {
    return fastPower(a, mod - 2, mod);  // í˜ë¥´ë§ˆì˜ ì†Œì •ë¦¬
}
```

### **í™•ì¥ ìœ í´ë¦¬ë“œ í˜¸ì œë²•**
```cpp
// ax + by = gcd(a, b)ì˜ í•´ êµ¬í•˜ê¸°
long long extendedGCD(long long a, long long b, long long& x, long long& y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    
    long long x1, y1;
    long long gcd = extendedGCD(b, a % b, x1, y1);
    
    x = y1;
    y = x1 - (a / b) * y1;
    
    return gcd;
}

// ëª¨ë“ˆëŸ¬ ì—­ì› (modê°€ ì†Œìˆ˜ê°€ ì•„ë‹ ë•Œ)
long long modInverseExtended(long long a, long long mod) {
    long long x, y;
    long long gcd = extendedGCD(a, mod, x, y);
    
    if (gcd != 1) return -1;  // ì—­ì›ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŒ
    
    return (x % mod + mod) % mod;
}

// ì¤‘êµ­ì¸ì˜ ë‚˜ë¨¸ì§€ ì •ë¦¬
pair<long long, long long> chineseRemainderTheorem(vector<long long>& remainders, 
                                                  vector<long long>& moduli) {
    long long M = 1;
    for (long long mod : moduli) {
        M *= mod;
    }
    
    long long result = 0;
    
    for (int i = 0; i < remainders.size(); i++) {
        long long Mi = M / moduli[i];
        long long yi = modInverseExtended(Mi, moduli[i]);
        
        if (yi == -1) return {-1, -1};  // í•´ê°€ ì—†ìŒ
        
        result = (result + remainders[i] * Mi * yi) % M;
    }
    
    return {(result + M) % M, M};
}
```

### **ì¡°í•©ë¡  ê³„ì‚°**
```cpp
const int MOD = 1000000007;
const int MAXN = 4000000;

vector<long long> factorial(MAXN + 1);
vector<long long> invFactorial(MAXN + 1);

void precomputeFactorials() {
    factorial[0] = 1;
    for (int i = 1; i <= MAXN; i++) {
        factorial[i] = (factorial[i - 1] * i) % MOD;
    }
    
    invFactorial[MAXN] = modInverse(factorial[MAXN], MOD);
    for (int i = MAXN - 1; i >= 0; i--) {
        invFactorial[i] = (invFactorial[i + 1] * (i + 1)) % MOD;
    }
}

long long combination(int n, int r) {
    if (r > n || r < 0) return 0;
    
    return (factorial[n] * invFactorial[r] % MOD) * invFactorial[n - r] % MOD;
}

long long permutation(int n, int r) {
    if (r > n || r < 0) return 0;
    
    return (factorial[n] * invFactorial[n - r]) % MOD;
}

// ì¤‘ë³µì¡°í•© H(n, r) = C(n + r - 1, r)
long long multicombination(int n, int r) {
    return combination(n + r - 1, r);
}

// ë£¨ì¹´ìŠ¤ ì •ë¦¬ (pê°€ ì‘ì€ ì†Œìˆ˜ì¼ ë•Œ)
long long lucasTheorem(long long n, long long r, long long p) {
    if (r == 0) return 1;
    
    return (combination(n % p, r % p) * lucasTheorem(n / p, r / p, p)) % p;
}
```

### **í–‰ë ¬ ê±°ë“­ì œê³±**
```cpp
template<int N>
struct Matrix {
    long long mat[N][N];
    
    Matrix() {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                mat[i][j] = 0;
            }
        }
    }
    
    Matrix operator*(const Matrix& other) const {
        Matrix result;
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                for (int k = 0; k < N; k++) {
                    result.mat[i][j] = (result.mat[i][j] + mat[i][k] * other.mat[k][j]) % MOD;
                }
            }
        }
        return result;
    }
    
    Matrix power(long long exp) const {
        Matrix result, base = *this;
        
        // ë‹¨ìœ„í–‰ë ¬ë¡œ ì´ˆê¸°í™”
        for (int i = 0; i < N; i++) {
            result.mat[i][i] = 1;
        }
        
        while (exp > 0) {
            if (exp & 1) {
                result = result * base;
            }
            base = base * base;
            exp >>= 1;
        }
        
        return result;
    }
};

// í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´ (í–‰ë ¬ ê±°ë“­ì œê³±)
long long fibonacciMatrix(long long n) {
    if (n == 0) return 0;
    if (n == 1) return 1;
    
    Matrix<2> base;
    base.mat[0][0] = 1; base.mat[0][1] = 1;
    base.mat[1][0] = 1; base.mat[1][1] = 0;
    
    Matrix<2> result = base.power(n - 1);
    
    return result.mat[0][0];  // F(n)
}
```

---

## ğŸ’¡ **ê³ ê¸‰ ê¸°ë²•**

### **1. ì´ì‚°ë¡œê·¸ (Discrete Logarithm)**
```cpp
// Baby-step Giant-step ì•Œê³ ë¦¬ì¦˜
long long discreteLog(long long a, long long b, long long mod) {
    long long n = sqrt(mod) + 1;
    
    // Baby steps: a^j for j = 0, 1, ..., n-1
    unordered_map<long long, long long> baby;
    long long current = 1;
    
    for (long long j = 0; j < n; j++) {
        if (baby.find(current) == baby.end()) {
            baby[current] = j;
        }
        current = (current * a) % mod;
    }
    
    // Giant steps: b * (a^(-n))^i for i = 0, 1, ..., n-1
    long long gamma = fastPower(a, mod - 1 - n, mod);  // a^(-n)
    long long y = b;
    
    for (long long i = 0; i < n; i++) {
        if (baby.find(y) != baby.end()) {
            long long answer = i * n + baby[y];
            if (answer > 0) return answer;
        }
        y = (y * gamma) % mod;
    }
    
    return -1;  // í•´ê°€ ì—†ìŒ
}
```

### **2. ë°€ëŸ¬-ë¼ë¹ˆ ì†Œìˆ˜ íŒì •ë²•**
```cpp
bool millerRabinTest(long long n, long long a) {
    if (n <= 1) return false;
    if (n == 2) return true;
    if (n % 2 == 0) return false;
    
    // n - 1 = d * 2^r
    long long d = n - 1;
    int r = 0;
    while (d % 2 == 0) {
        d /= 2;
        r++;
    }
    
    long long x = fastPower(a, d, n);
    if (x == 1 || x == n - 1) return true;
    
    for (int i = 0; i < r - 1; i++) {
        x = (x * x) % n;
        if (x == n - 1) return true;
    }
    
    return false;
}

bool isPrimeMR(long long n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 == 0) return false;
    
    // í™•ë¥ ì  íŒì •ì„ ìœ„í•œ witnesses
    vector<long long> witnesses = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};
    
    for (long long a : witnesses) {
        if (a >= n) break;
        if (!millerRabinTest(n, a)) return false;
    }
    
    return true;
}
```

### **3. í´ë¼ë“œ ë¡œ ì†Œì¸ìˆ˜ë¶„í•´**
```cpp
long long pollardRho(long long n) {
    if (n % 2 == 0) return 2;
    
    long long x = 2, y = 2, d = 1;
    
    auto f = [&](long long x) -> long long {
        return (x * x + 1) % n;
    };
    
    while (d == 1) {
        x = f(x);
        y = f(f(y));
        d = __gcd(abs(x - y), n);
    }
    
    return d == n ? -1 : d;
}

vector<long long> factorize(long long n) {
    vector<long long> factors;
    
    function<void(long long)> factor = [&](long long num) {
        if (num == 1) return;
        
        if (isPrimeMR(num)) {
            factors.push_back(num);
            return;
        }
        
        long long divisor = pollardRho(num);
        if (divisor == -1) {
            factors.push_back(num);
            return;
        }
        
        factor(divisor);
        factor(num / divisor);
    };
    
    factor(n);
    sort(factors.begin(), factors.end());
    return factors;
}
```

### **4. NTT (Number Theoretic Transform)**
```cpp
const long long NTT_MOD = 998244353;
const long long NTT_ROOT = 3;

long long nttPower(long long base, long long exp, long long mod) {
    long long result = 1;
    while (exp > 0) {
        if (exp & 1) result = (result * base) % mod;
        base = (base * base) % mod;
        exp >>= 1;
    }
    return result;
}

void ntt(vector<long long>& a, bool inverse) {
    int n = a.size();
    
    // Bit-reversal
    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1) {
            j ^= bit;
        }
        j ^= bit;
        if (i < j) swap(a[i], a[j]);
    }
    
    for (int len = 2; len <= n; len <<= 1) {
        long long wlen = nttPower(NTT_ROOT, (NTT_MOD - 1) / len, NTT_MOD);
        if (inverse) wlen = nttPower(wlen, NTT_MOD - 2, NTT_MOD);
        
        for (int i = 0; i < n; i += len) {
            long long w = 1;
            for (int j = 0; j < len / 2; j++) {
                long long u = a[i + j];
                long long v = (a[i + j + len / 2] * w) % NTT_MOD;
                
                a[i + j] = (u + v) % NTT_MOD;
                a[i + j + len / 2] = (u - v + NTT_MOD) % NTT_MOD;
                
                w = (w * wlen) % NTT_MOD;
            }
        }
    }
    
    if (inverse) {
        long long inv_n = nttPower(n, NTT_MOD - 2, NTT_MOD);
        for (long long& x : a) {
            x = (x * inv_n) % NTT_MOD;
        }
    }
}

vector<long long> multiply(vector<long long> a, vector<long long> b) {
    int n = 1;
    while (n < a.size() + b.size()) n <<= 1;
    
    a.resize(n);
    b.resize(n);
    
    ntt(a, false);
    ntt(b, false);
    
    for (int i = 0; i < n; i++) {
        a[i] = (a[i] * b[i]) % NTT_MOD;
    }
    
    ntt(a, true);
    
    vector<long long> result(a.size() + b.size() - 1);
    for (int i = 0; i < result.size(); i++) {
        result[i] = a[i];
    }
    
    return result;
}
```

---

## ğŸ” **ì‹¤ì œ ì˜ˆì‹œ**

### **ì˜ˆì‹œ 1: ê³±ì…ˆ (1629ë²ˆ)**
```cpp
#include <iostream>

long long fastPower(long long base, long long exp, long long mod) {
    long long result = 1;
    base %= mod;
    
    while (exp > 0) {
        if (exp & 1) {
            result = (result * base) % mod;
        }
        base = (base * base) % mod;
        exp >>= 1;
    }
    
    return result;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    long long a, b, c;
    cin >> a >> b >> c;
    
    cout << fastPower(a, b, c) << "\n";
    
    return 0;
}
```

### **ì˜ˆì‹œ 2: ì´í•­ ê³„ìˆ˜ 3 (11401ë²ˆ)**
```cpp
#include <iostream>
#include <vector>

const int MOD = 1000000007;
const int MAXN = 4000000;

vector<long long> factorial(MAXN + 1);
vector<long long> invFactorial(MAXN + 1);

long long fastPower(long long base, long long exp, long long mod) {
    long long result = 1;
    while (exp > 0) {
        if (exp & 1) result = (result * base) % mod;
        base = (base * base) % mod;
        exp >>= 1;
    }
    return result;
}

void precompute() {
    factorial[0] = 1;
    for (int i = 1; i <= MAXN; i++) {
        factorial[i] = (factorial[i - 1] * i) % MOD;
    }
    
    invFactorial[MAXN] = fastPower(factorial[MAXN], MOD - 2, MOD);
    for (int i = MAXN - 1; i >= 0; i--) {
        invFactorial[i] = (invFactorial[i + 1] * (i + 1)) % MOD;
    }
}

long long combination(int n, int k) {
    if (k > n || k < 0) return 0;
    return (factorial[n] * invFactorial[k] % MOD) * invFactorial[n - k] % MOD;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    precompute();
    
    int n, k;
    cin >> n >> k;
    
    cout << combination(n, k) << "\n";
    
    return 0;
}
```

### **ì˜ˆì‹œ 3: í”¼ë³´ë‚˜ì¹˜ ìˆ˜ 3 (2749ë²ˆ)**
```cpp
#include <iostream>
#include <vector>

const int MOD = 1000000;

struct Matrix {
    long long mat[2][2];
    
    Matrix() {
        mat[0][0] = mat[0][1] = mat[1][0] = mat[1][1] = 0;
    }
    
    Matrix(long long a, long long b, long long c, long long d) {
        mat[0][0] = a; mat[0][1] = b;
        mat[1][0] = c; mat[1][1] = d;
    }
    
    Matrix operator*(const Matrix& other) const {
        Matrix result;
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                for (int k = 0; k < 2; k++) {
                    result.mat[i][j] = (result.mat[i][j] + mat[i][k] * other.mat[k][j]) % MOD;
                }
            }
        }
        return result;
    }
};

Matrix matrixPower(Matrix base, long long exp) {
    Matrix result(1, 0, 0, 1);  // ë‹¨ìœ„í–‰ë ¬
    
    while (exp > 0) {
        if (exp & 1) {
            result = result * base;
        }
        base = base * base;
        exp >>= 1;
    }
    
    return result;
}

long long fibonacci(long long n) {
    if (n == 0) return 0;
    if (n == 1) return 1;
    
    Matrix base(1, 1, 1, 0);
    Matrix result = matrixPower(base, n - 1);
    
    return result.mat[0][0];
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    long long n;
    cin >> n;
    
    cout << fibonacci(n) << "\n";
    
    return 0;
}
```

---

## âš¡ **ìµœì í™” íŒ**

### **1. ì „ì²˜ë¦¬ ìµœì í™”**
```cpp
// ëª¨ë“  ì—­ì›ì„ O(n)ì— ê³„ì‚°
vector<long long> modInverses(int n, int mod) {
    vector<long long> inv(n + 1);
    inv[1] = 1;
    
    for (int i = 2; i <= n; i++) {
        inv[i] = (mod - (mod / i) * inv[mod % i] % mod) % mod;
    }
    
    return inv;
}
```

### **2. ìºì‹±**
```cpp
// ì´ë¯¸ ê³„ì‚°ëœ ê±°ë“­ì œê³± ê²°ê³¼ ì €ì¥
unordered_map<pair<long long, long long>, long long> powerCache;

long long cachedPower(long long base, long long exp, long long mod) {
    auto key = make_pair(base, exp);
    if (powerCache.count(key)) {
        return powerCache[key];
    }
    
    return powerCache[key] = fastPower(base, exp, mod);
}
```

---

## ğŸ“Š **ì‹œê°„ ë³µì¡ë„**

- **ë¹ ë¥¸ ê±°ë“­ì œê³±**: O(log n)
- **í™•ì¥ ìœ í´ë¦¬ë“œ**: O(log min(a, b))
- **ì¡°í•© ì „ì²˜ë¦¬**: O(n)
- **ì¡°í•© ê³„ì‚°**: O(1) (ì „ì²˜ë¦¬ í›„)
- **í–‰ë ¬ ê±°ë“­ì œê³±**: O(kÂ³ log n) (kÃ—k í–‰ë ¬)

---

## ğŸ“ **ê´€ë ¨ ë¬¸ì œ**

### **ê±°ë“­ì œê³±**
- 1629: ê³±ì…ˆ
- 1735: ë¶„ìˆ˜ í•©
- 13172: Î£

### **ì¡°í•©ë¡ **
- 11401: ì´í•­ ê³„ìˆ˜ 3
- 1010: ë‹¤ë¦¬ ë†“ê¸°
- 11050: ì´í•­ ê³„ìˆ˜ 1

### **í–‰ë ¬ ê±°ë“­ì œê³±**
- 2749: í”¼ë³´ë‚˜ì¹˜ ìˆ˜ 3
- 11444: í”¼ë³´ë‚˜ì¹˜ ìˆ˜ 6
- 12850: ë³¸ëŒ€ ì‚°ì±…2

### **ì •ìˆ˜ë¡ **
- 1837: ì•”í˜¸ì œì‘
- 4375: 1
- 2960: ì—ë¼í† ìŠ¤í…Œë„¤ìŠ¤ì˜ ì²´

---

**ğŸ”‘ í•µì‹¬ í¬ì¸íŠ¸**:
- **ë¹ ë¥¸ ê±°ë“­ì œê³±**ìœ¼ë¡œ ì§€ìˆ˜ ê³„ì‚° ìµœì í™”
- **ëª¨ë“ˆëŸ¬ ì—°ì‚°** ê·œì¹™ ì •í™•íˆ ì ìš©
- **ì „ì²˜ë¦¬**ë¡œ ë°˜ë³µ ê³„ì‚° ìµœì í™”
- **í–‰ë ¬ ê±°ë“­ì œê³±**ìœ¼ë¡œ ì í™”ì‹ ê°€ì†í™”