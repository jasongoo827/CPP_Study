# 🧮 고급 수학

> **난이도**: Gold ~ Platinum  
> **대표 문제**: 1629(곱셈), 11401(이항 계수 3), 2749(피보나치 수 3)

---

## 🎯 **핵심 개념**

고급 수학은 **수론과 조합론의 효율적 계산**을 다룹니다:
- **빠른 거듭제곱(Fast Exponentiation)**: O(log n) 거듭제곱
- **모듈러 연산**: 큰 수의 나머지 계산
- **확장 유클리드 호제법**: 역원 계산
- **행렬 거듭제곱**: 점화식 가속화

---

## 🔧 **기본 템플릿**

### **빠른 거듭제곱**
```cpp
// 기본 빠른 거듭제곱
long long fastPower(long long base, long long exp, long long mod) {
    long long result = 1;
    base %= mod;
    
    while (exp > 0) {
        if (exp & 1) {
            result = (result * base) % mod;
        }
        base = (base * base) % mod;
        exp >>= 1;
    }
    
    return result;
}

// 재귀 버전
long long fastPowerRecursive(long long base, long long exp, long long mod) {
    if (exp == 0) return 1;
    
    long long half = fastPowerRecursive(base, exp / 2, mod);
    half = (half * half) % mod;
    
    if (exp & 1) {
        half = (half * base) % mod;
    }
    
    return half;
}

// 모듈러 역원 계산 (mod가 소수일 때)
long long modInverse(long long a, long long mod) {
    return fastPower(a, mod - 2, mod);  // 페르마의 소정리
}
```

### **확장 유클리드 호제법**
```cpp
// ax + by = gcd(a, b)의 해 구하기
long long extendedGCD(long long a, long long b, long long& x, long long& y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    
    long long x1, y1;
    long long gcd = extendedGCD(b, a % b, x1, y1);
    
    x = y1;
    y = x1 - (a / b) * y1;
    
    return gcd;
}

// 모듈러 역원 (mod가 소수가 아닐 때)
long long modInverseExtended(long long a, long long mod) {
    long long x, y;
    long long gcd = extendedGCD(a, mod, x, y);
    
    if (gcd != 1) return -1;  // 역원이 존재하지 않음
    
    return (x % mod + mod) % mod;
}

// 중국인의 나머지 정리
pair<long long, long long> chineseRemainderTheorem(vector<long long>& remainders, 
                                                  vector<long long>& moduli) {
    long long M = 1;
    for (long long mod : moduli) {
        M *= mod;
    }
    
    long long result = 0;
    
    for (int i = 0; i < remainders.size(); i++) {
        long long Mi = M / moduli[i];
        long long yi = modInverseExtended(Mi, moduli[i]);
        
        if (yi == -1) return {-1, -1};  // 해가 없음
        
        result = (result + remainders[i] * Mi * yi) % M;
    }
    
    return {(result + M) % M, M};
}
```

### **조합론 계산**
```cpp
const int MOD = 1000000007;
const int MAXN = 4000000;

vector<long long> factorial(MAXN + 1);
vector<long long> invFactorial(MAXN + 1);

void precomputeFactorials() {
    factorial[0] = 1;
    for (int i = 1; i <= MAXN; i++) {
        factorial[i] = (factorial[i - 1] * i) % MOD;
    }
    
    invFactorial[MAXN] = modInverse(factorial[MAXN], MOD);
    for (int i = MAXN - 1; i >= 0; i--) {
        invFactorial[i] = (invFactorial[i + 1] * (i + 1)) % MOD;
    }
}

long long combination(int n, int r) {
    if (r > n || r < 0) return 0;
    
    return (factorial[n] * invFactorial[r] % MOD) * invFactorial[n - r] % MOD;
}

long long permutation(int n, int r) {
    if (r > n || r < 0) return 0;
    
    return (factorial[n] * invFactorial[n - r]) % MOD;
}

// 중복조합 H(n, r) = C(n + r - 1, r)
long long multicombination(int n, int r) {
    return combination(n + r - 1, r);
}

// 루카스 정리 (p가 작은 소수일 때)
long long lucasTheorem(long long n, long long r, long long p) {
    if (r == 0) return 1;
    
    return (combination(n % p, r % p) * lucasTheorem(n / p, r / p, p)) % p;
}
```

### **행렬 거듭제곱**
```cpp
template<int N>
struct Matrix {
    long long mat[N][N];
    
    Matrix() {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                mat[i][j] = 0;
            }
        }
    }
    
    Matrix operator*(const Matrix& other) const {
        Matrix result;
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                for (int k = 0; k < N; k++) {
                    result.mat[i][j] = (result.mat[i][j] + mat[i][k] * other.mat[k][j]) % MOD;
                }
            }
        }
        return result;
    }
    
    Matrix power(long long exp) const {
        Matrix result, base = *this;
        
        // 단위행렬로 초기화
        for (int i = 0; i < N; i++) {
            result.mat[i][i] = 1;
        }
        
        while (exp > 0) {
            if (exp & 1) {
                result = result * base;
            }
            base = base * base;
            exp >>= 1;
        }
        
        return result;
    }
};

// 피보나치 수열 (행렬 거듭제곱)
long long fibonacciMatrix(long long n) {
    if (n == 0) return 0;
    if (n == 1) return 1;
    
    Matrix<2> base;
    base.mat[0][0] = 1; base.mat[0][1] = 1;
    base.mat[1][0] = 1; base.mat[1][1] = 0;
    
    Matrix<2> result = base.power(n - 1);
    
    return result.mat[0][0];  // F(n)
}
```

---

## 💡 **고급 기법**

### **1. 이산로그 (Discrete Logarithm)**
```cpp
// Baby-step Giant-step 알고리즘
long long discreteLog(long long a, long long b, long long mod) {
    long long n = sqrt(mod) + 1;
    
    // Baby steps: a^j for j = 0, 1, ..., n-1
    unordered_map<long long, long long> baby;
    long long current = 1;
    
    for (long long j = 0; j < n; j++) {
        if (baby.find(current) == baby.end()) {
            baby[current] = j;
        }
        current = (current * a) % mod;
    }
    
    // Giant steps: b * (a^(-n))^i for i = 0, 1, ..., n-1
    long long gamma = fastPower(a, mod - 1 - n, mod);  // a^(-n)
    long long y = b;
    
    for (long long i = 0; i < n; i++) {
        if (baby.find(y) != baby.end()) {
            long long answer = i * n + baby[y];
            if (answer > 0) return answer;
        }
        y = (y * gamma) % mod;
    }
    
    return -1;  // 해가 없음
}
```

### **2. 밀러-라빈 소수 판정법**
```cpp
bool millerRabinTest(long long n, long long a) {
    if (n <= 1) return false;
    if (n == 2) return true;
    if (n % 2 == 0) return false;
    
    // n - 1 = d * 2^r
    long long d = n - 1;
    int r = 0;
    while (d % 2 == 0) {
        d /= 2;
        r++;
    }
    
    long long x = fastPower(a, d, n);
    if (x == 1 || x == n - 1) return true;
    
    for (int i = 0; i < r - 1; i++) {
        x = (x * x) % n;
        if (x == n - 1) return true;
    }
    
    return false;
}

bool isPrimeMR(long long n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 == 0) return false;
    
    // 확률적 판정을 위한 witnesses
    vector<long long> witnesses = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};
    
    for (long long a : witnesses) {
        if (a >= n) break;
        if (!millerRabinTest(n, a)) return false;
    }
    
    return true;
}
```

### **3. 폴라드 로 소인수분해**
```cpp
long long pollardRho(long long n) {
    if (n % 2 == 0) return 2;
    
    long long x = 2, y = 2, d = 1;
    
    auto f = [&](long long x) -> long long {
        return (x * x + 1) % n;
    };
    
    while (d == 1) {
        x = f(x);
        y = f(f(y));
        d = __gcd(abs(x - y), n);
    }
    
    return d == n ? -1 : d;
}

vector<long long> factorize(long long n) {
    vector<long long> factors;
    
    function<void(long long)> factor = [&](long long num) {
        if (num == 1) return;
        
        if (isPrimeMR(num)) {
            factors.push_back(num);
            return;
        }
        
        long long divisor = pollardRho(num);
        if (divisor == -1) {
            factors.push_back(num);
            return;
        }
        
        factor(divisor);
        factor(num / divisor);
    };
    
    factor(n);
    sort(factors.begin(), factors.end());
    return factors;
}
```

### **4. NTT (Number Theoretic Transform)**
```cpp
const long long NTT_MOD = 998244353;
const long long NTT_ROOT = 3;

long long nttPower(long long base, long long exp, long long mod) {
    long long result = 1;
    while (exp > 0) {
        if (exp & 1) result = (result * base) % mod;
        base = (base * base) % mod;
        exp >>= 1;
    }
    return result;
}

void ntt(vector<long long>& a, bool inverse) {
    int n = a.size();
    
    // Bit-reversal
    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1) {
            j ^= bit;
        }
        j ^= bit;
        if (i < j) swap(a[i], a[j]);
    }
    
    for (int len = 2; len <= n; len <<= 1) {
        long long wlen = nttPower(NTT_ROOT, (NTT_MOD - 1) / len, NTT_MOD);
        if (inverse) wlen = nttPower(wlen, NTT_MOD - 2, NTT_MOD);
        
        for (int i = 0; i < n; i += len) {
            long long w = 1;
            for (int j = 0; j < len / 2; j++) {
                long long u = a[i + j];
                long long v = (a[i + j + len / 2] * w) % NTT_MOD;
                
                a[i + j] = (u + v) % NTT_MOD;
                a[i + j + len / 2] = (u - v + NTT_MOD) % NTT_MOD;
                
                w = (w * wlen) % NTT_MOD;
            }
        }
    }
    
    if (inverse) {
        long long inv_n = nttPower(n, NTT_MOD - 2, NTT_MOD);
        for (long long& x : a) {
            x = (x * inv_n) % NTT_MOD;
        }
    }
}

vector<long long> multiply(vector<long long> a, vector<long long> b) {
    int n = 1;
    while (n < a.size() + b.size()) n <<= 1;
    
    a.resize(n);
    b.resize(n);
    
    ntt(a, false);
    ntt(b, false);
    
    for (int i = 0; i < n; i++) {
        a[i] = (a[i] * b[i]) % NTT_MOD;
    }
    
    ntt(a, true);
    
    vector<long long> result(a.size() + b.size() - 1);
    for (int i = 0; i < result.size(); i++) {
        result[i] = a[i];
    }
    
    return result;
}
```

---

## 🔍 **실제 예시**

### **예시 1: 곱셈 (1629번)**
```cpp
#include <iostream>

long long fastPower(long long base, long long exp, long long mod) {
    long long result = 1;
    base %= mod;
    
    while (exp > 0) {
        if (exp & 1) {
            result = (result * base) % mod;
        }
        base = (base * base) % mod;
        exp >>= 1;
    }
    
    return result;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    long long a, b, c;
    cin >> a >> b >> c;
    
    cout << fastPower(a, b, c) << "\n";
    
    return 0;
}
```

### **예시 2: 이항 계수 3 (11401번)**
```cpp
#include <iostream>
#include <vector>

const int MOD = 1000000007;
const int MAXN = 4000000;

vector<long long> factorial(MAXN + 1);
vector<long long> invFactorial(MAXN + 1);

long long fastPower(long long base, long long exp, long long mod) {
    long long result = 1;
    while (exp > 0) {
        if (exp & 1) result = (result * base) % mod;
        base = (base * base) % mod;
        exp >>= 1;
    }
    return result;
}

void precompute() {
    factorial[0] = 1;
    for (int i = 1; i <= MAXN; i++) {
        factorial[i] = (factorial[i - 1] * i) % MOD;
    }
    
    invFactorial[MAXN] = fastPower(factorial[MAXN], MOD - 2, MOD);
    for (int i = MAXN - 1; i >= 0; i--) {
        invFactorial[i] = (invFactorial[i + 1] * (i + 1)) % MOD;
    }
}

long long combination(int n, int k) {
    if (k > n || k < 0) return 0;
    return (factorial[n] * invFactorial[k] % MOD) * invFactorial[n - k] % MOD;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    precompute();
    
    int n, k;
    cin >> n >> k;
    
    cout << combination(n, k) << "\n";
    
    return 0;
}
```

### **예시 3: 피보나치 수 3 (2749번)**
```cpp
#include <iostream>
#include <vector>

const int MOD = 1000000;

struct Matrix {
    long long mat[2][2];
    
    Matrix() {
        mat[0][0] = mat[0][1] = mat[1][0] = mat[1][1] = 0;
    }
    
    Matrix(long long a, long long b, long long c, long long d) {
        mat[0][0] = a; mat[0][1] = b;
        mat[1][0] = c; mat[1][1] = d;
    }
    
    Matrix operator*(const Matrix& other) const {
        Matrix result;
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                for (int k = 0; k < 2; k++) {
                    result.mat[i][j] = (result.mat[i][j] + mat[i][k] * other.mat[k][j]) % MOD;
                }
            }
        }
        return result;
    }
};

Matrix matrixPower(Matrix base, long long exp) {
    Matrix result(1, 0, 0, 1);  // 단위행렬
    
    while (exp > 0) {
        if (exp & 1) {
            result = result * base;
        }
        base = base * base;
        exp >>= 1;
    }
    
    return result;
}

long long fibonacci(long long n) {
    if (n == 0) return 0;
    if (n == 1) return 1;
    
    Matrix base(1, 1, 1, 0);
    Matrix result = matrixPower(base, n - 1);
    
    return result.mat[0][0];
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    long long n;
    cin >> n;
    
    cout << fibonacci(n) << "\n";
    
    return 0;
}
```

---

## ⚡ **최적화 팁**

### **1. 전처리 최적화**
```cpp
// 모든 역원을 O(n)에 계산
vector<long long> modInverses(int n, int mod) {
    vector<long long> inv(n + 1);
    inv[1] = 1;
    
    for (int i = 2; i <= n; i++) {
        inv[i] = (mod - (mod / i) * inv[mod % i] % mod) % mod;
    }
    
    return inv;
}
```

### **2. 캐싱**
```cpp
// 이미 계산된 거듭제곱 결과 저장
unordered_map<pair<long long, long long>, long long> powerCache;

long long cachedPower(long long base, long long exp, long long mod) {
    auto key = make_pair(base, exp);
    if (powerCache.count(key)) {
        return powerCache[key];
    }
    
    return powerCache[key] = fastPower(base, exp, mod);
}
```

---

## 📊 **시간 복잡도**

- **빠른 거듭제곱**: O(log n)
- **확장 유클리드**: O(log min(a, b))
- **조합 전처리**: O(n)
- **조합 계산**: O(1) (전처리 후)
- **행렬 거듭제곱**: O(k³ log n) (k×k 행렬)

---

## 📝 **관련 문제**

### **거듭제곱**
- 1629: 곱셈
- 1735: 분수 합
- 13172: Σ

### **조합론**
- 11401: 이항 계수 3
- 1010: 다리 놓기
- 11050: 이항 계수 1

### **행렬 거듭제곱**
- 2749: 피보나치 수 3
- 11444: 피보나치 수 6
- 12850: 본대 산책2

### **정수론**
- 1837: 암호제작
- 4375: 1
- 2960: 에라토스테네스의 체

---

**🔑 핵심 포인트**:
- **빠른 거듭제곱**으로 지수 계산 최적화
- **모듈러 연산** 규칙 정확히 적용
- **전처리**로 반복 계산 최적화
- **행렬 거듭제곱**으로 점화식 가속화